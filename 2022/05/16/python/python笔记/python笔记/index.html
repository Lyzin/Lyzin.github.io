<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Python基础编程 | 笔记小窝</title><meta name="keywords" content="Python"><meta name="author" content="刘阳"><meta name="copyright" content="刘阳"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高质量代码：不是越少越好，而是让刚入门的小白也能看懂的才是优质代码  一、基本数据类型1、变量1name &#x3D; &quot;sam&quot;   变量定义的过程：  在内存中开辟一片内存空间，将name这个变量的值name存到开辟的内存空间中，将name绑定到sam这个值上，所以name就是sam这个值的引用标签 变量等号左侧是变量名，变量右侧等号是具体的值才算产生新值，开辟新的内存空间来存值">
<meta property="og:type" content="article">
<meta property="og:title" content="Python基础编程">
<meta property="og:url" content="https://www.lynote.top/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="笔记小窝">
<meta property="og:description" content="高质量代码：不是越少越好，而是让刚入门的小白也能看懂的才是优质代码  一、基本数据类型1、变量1name &#x3D; &quot;sam&quot;   变量定义的过程：  在内存中开辟一片内存空间，将name这个变量的值name存到开辟的内存空间中，将name绑定到sam这个值上，所以name就是sam这个值的引用标签 变量等号左侧是变量名，变量右侧等号是具体的值才算产生新值，开辟新的内存空间来存值">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.lynote.top/posts_cover_img/python/python_logo.jpeg">
<meta property="article:published_time" content="2022-05-16T11:31:21.000Z">
<meta property="article:modified_time" content="2024-09-26T03:14:28.754Z">
<meta property="article:author" content="刘阳">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.lynote.top/posts_cover_img/python/python_logo.jpeg"><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="https://www.lynote.top/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python基础编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-26 11:14:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 博客分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 文章标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 博客归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/posts_cover_img/python/python_logo.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">笔记小窝</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 博客分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 文章标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 博客归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python基础编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-16T11:31:21.000Z" title="发表于 2022-05-16 19:31:21">2022-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-26T03:14:28.754Z" title="更新于 2024-09-26 11:14:28">2024-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/">Python基础编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python基础编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>高质量代码：不是越少越好，而是让刚入门的小白也能看懂的才是优质代码</p>
</blockquote>
<h2 id="一、基本数据类型"><a href="#一、基本数据类型" class="headerlink" title="一、基本数据类型"></a>一、基本数据类型</h2><h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;sam&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量定义的过程：</p>
<ul>
<li>在内存中开辟一片内存空间，将<code>name</code>这个变量的值<code>name</code>存到开辟的内存空间中，将name绑定到<code>sam</code>这个值上，所以<code>name</code>就是<code>sam</code>这个值的引用标签</li>
<li>变量等号左侧是变量名，变量右侧等号是具体的值才算产生新值，开辟新的内存空间来存值</li>
<li>x&#x3D;10在内存中的理解<ul>
<li>栈区：存放的是变量名和内存地址的对应关系，简单理解为变量名存了内存地址</li>
<li>堆区：存放的是变量名</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="1-1-变量的三大特性"><a href="#1-1-变量的三大特性" class="headerlink" title="1.1 变量的三大特性"></a>1.1 变量的三大特性</h4><blockquote>
<ul>
<li>id<ul>
<li>反映的是变量值的内存地址，是根据变量值计算出来的一串数字，也可以理解为内存地址id</li>
</ul>
</li>
<li>type<ul>
<li>变量的类型，比如:整型、浮点型、字符串等等</li>
</ul>
</li>
<li>值<ul>
<li>就是变量值</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="1-2-is和-x3D-x3D"><a href="#1-2-is和-x3D-x3D" class="headerlink" title="1.2 is和&#x3D;&#x3D;"></a>1.2 is和&#x3D;&#x3D;</h4><blockquote>
<ul>
<li>is<ul>
<li>比较的是左右两个值身份id是否相同</li>
</ul>
</li>
<li>&#x3D;&#x3D;<ul>
<li>比较左右两个值是否相同，是表面上的值，也就是可以看到的值</li>
</ul>
</li>
<li>python解释器在启动时会在内存中加载一个<code>小整数池</code>，在这个整数池内定义的所有变量的id都一样，小整数池范围是:<code>-5~256</code>，这样提高了访问速度，没必要每次赋值都在内存开辟内存空间，这是python自己的优化</li>
<li>在<code>pycharm</code>中会出现<code>-5~256</code>这个范围外的id也会一样，这是因为<code>pycharm</code>自己做的优化，会将更大范围的整数池加载到内存，这也是<code>pycharm</code>占用大量内存的原因之一</li>
<li>那到底应该以python解释器的范围为准还是以<code>pycharm</code>为准呢？肯定是以python解释器为准，因为最终运行python代码肯定是用python解释器来运行的，<code>pycharm</code>只是开发工具，将python代码部署到服务器上肯定也是python解释器来运行的</li>
<li>另外python解释器也有<code>小字符串池</code>概念，也就是在小字符串池的字符串id一样</li>
</ul>
</blockquote>
<h4 id="1-3-常量"><a href="#1-3-常量" class="headerlink" title="1.3 常量"></a>1.3 常量</h4><blockquote>
<ul>
<li><p>python没有常量的概念</p>
</li>
<li><p>约定成俗的是<code>变量名全大写</code>就是常量</p>
</li>
</ul>
</blockquote>
<h3 id="2、str字符串"><a href="#2、str字符串" class="headerlink" title="2、str字符串"></a>2、<code>str</code>字符串</h3><blockquote>
<p>字符串的拼接，使用+号，但是这种形式效率比较低，不推荐使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;sam&quot;</span></span><br><span class="line">sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">info = name + sex</span><br><span class="line"><span class="built_in">print</span>(info)</span><br></pre></td></tr></table></figure>

<h3 id="3、bool布尔值"><a href="#3、bool布尔值" class="headerlink" title="3、bool布尔值"></a>3、<code>bool</code>布尔值</h3><blockquote>
<ul>
<li>只有两个值，常用于条件判断<ul>
<li>true：真</li>
<li>false：假</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4、list列表"><a href="#4、list列表" class="headerlink" title="4、list列表"></a>4、list列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_list = [<span class="string">&quot;sam&quot;</span>, <span class="string">&quot;jam&quot;</span>, <span class="string">&quot;tom&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;user_list:<span class="subst">&#123;user_list&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5、tuple元组"><a href="#5、tuple元组" class="headerlink" title="5、tuple元组"></a>5、tuple元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_tuple = (<span class="string">&quot;sam&quot;</span>, <span class="string">&quot;jam&quot;</span>, <span class="string">&quot;tom&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;user_tuple:<span class="subst">&#123;user_tuple&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6、字典"><a href="#6、字典" class="headerlink" title="6、字典"></a>6、字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user_dict = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;sam&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="string">&quot;hobby&quot;</span>: [<span class="string">&quot;feet&quot;</span>, <span class="string">&quot;beet&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;user_dict:<span class="subst">&#123;user_dict&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7、垃圾回收机制"><a href="#7、垃圾回收机制" class="headerlink" title="7、垃圾回收机制"></a>7、垃圾回收机制</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108683483">https://zhuanlan.zhihu.com/p/108683483</a></p>
</blockquote>
<blockquote>
<ul>
<li><p>概念</p>
<ul>
<li>垃圾回收机制(GC)是python自带的内存管理机制，用来回收不可用的变量值所占用的内存空间</li>
</ul>
</li>
<li><p>为什么要有垃圾回收</p>
<ul>
<li>程序运行过程中会申请大量的内存空间，而对于一些无用的内存空间如果不及时清理的话会导致内存使用殆尽（内存溢出），导致程序崩溃，因此管理内存是一件重要且繁杂的事情，而python解释器自带的垃圾回收机制把程序员从繁杂的内存管理中解放出来。</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题，并且通过“分代回收”（generation collection）以空间换取时间的方式来进一步提高垃圾回收的效率。</li>
</ul>
</li>
<li><p>三个特性：</p>
<ul>
<li>引用计数</li>
<li>标记清除</li>
<li>分代回收</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="1-1-引用计数"><a href="#1-1-引用计数" class="headerlink" title="1.1 引用计数"></a>1.1 引用计数</h4><blockquote>
<ul>
<li><p>直接引用</p>
<ul>
<li>指的是从栈区出发直接引用到的内存地址。</li>
</ul>
</li>
<li><p>间接引用</p>
</li>
<li><p>指的是从栈区出发引用到堆区后，再通过进一步引用才能到达的内存地址。</p>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表本身被变量名l2直接引用，包含的元素被列表间接引用</span></span><br><span class="line">l2 = [<span class="number">20</span>, <span class="number">30</span>]  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 值10被变量名x直接引用</span></span><br><span class="line">x = <span class="number">10</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表本身被变量名l1直接引用，包含的元素被列表间接引用</span></span><br><span class="line">l1 = [x, l2]  </span><br></pre></td></tr></table></figure>

<h4 id="1-2-标记清除"><a href="#1-2-标记清除" class="headerlink" title="1.2 标记清除"></a>1.2 标记清除</h4><blockquote>
<p>是为了解决循环引用的缺陷，内存泄露（内存一直被占用无法释放）</p>
<ul>
<li>标记<ul>
<li>通俗地讲就是：<br>栈区相当于“根”，凡是从根出发可以访达（直接或间接引用）的，都称之为“有根之人”，有根之人当活，无根之人当死。</li>
<li>具体地：标记的过程其实就是，遍历所有的GC Roots对象(栈区中的所有内容或者线程都可以作为GC Roots对象），然后将所有GC Roots的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除。</li>
</ul>
</li>
<li>清除<ul>
<li>将遍历堆中所有的对象，将没有标记的对象全部清除掉。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="1-3-分代回收"><a href="#1-3-分代回收" class="headerlink" title="1.3  分代回收"></a>1.3  分代回收</h4><blockquote>
<ul>
<li><p>主要是为了提高循环引用清除的效率问题</p>
</li>
<li><p>分代</p>
<ul>
<li>在历经多次扫描的情况下，都没有被回收的变量，gc机制就会认为，该变量是常用变量，gc对其扫描的频率会降低，具体实现原理如下：</li>
<li>分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）</li>
<li>新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，<code>如果发现变量依然被引用</code>，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低</li>
</ul>
</li>
<li><p>回收</p>
<ul>
<li>回收依然是使用引用计数作为回收的依据</li>
<li>垃圾回收机制是在清理垃圾&amp;释放内存的大背景下，允许分代回收以极小部分垃圾不会被及时释放为代价，以此换取引用计数整体扫描频率的降低，从而提升其性能，这是一种以空间换时间的解决方案目录</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="8、编解码"><a href="#8、编解码" class="headerlink" title="8、编解码"></a>8、编解码</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jin-xin/articles/10577131.html#_label14">https://www.cnblogs.com/jin-xin/articles/10577131.html#_label14</a></p>
</blockquote>
<blockquote>
<ul>
<li>unicode转换为bytes称为编码,也就是encode</li>
<li>bytes转化为unicode称为解码,也就是decode</li>
<li>数据在内存中是以unicode编码形式存在，但是当数据用于网络传输或者存储到硬盘，必须以非unicode编码存储（utf-8,gbk等格式，这些格式的编码方式是bytes(字节类型)），数据不止字符串、代码等等都是数据</li>
<li>用文件编辑器（word，wps,等）编辑文件的时候，从文件将你的数据（此时你的数据是非Unicode（可能是UTF-8，也可能是gbk，这个编码取决于你的编辑器设置））字符被转换为Unicode字符读到内存里，进行相应的编辑，编辑完成后，保存的时候再把Unicode转换为非Unicode（UTF-8，GBK 等）保存到文件。</li>
</ul>
</blockquote>
<h4 id="1-1-str类型"><a href="#1-1-str类型" class="headerlink" title="1.1 str类型"></a>1.1 str类型</h4><blockquote>
<ul>
<li>内部编码：unicode</li>
<li>内容示例<ul>
<li>英文： ‘sam’</li>
<li>中文： ‘中国’</li>
</ul>
</li>
<li>组成单位: 字符</li>
<li>弊端<ul>
<li>Unicode编码的数据不可以存储到磁盘中，也不能进行网络传输</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="1-2-bytes类型"><a href="#1-2-bytes类型" class="headerlink" title="1.2 bytes类型"></a>1.2 bytes类型</h4><blockquote>
<ul>
<li>内部编码：可指定编码（除Unicode之外），比如UTF-8，GBK 等都是bytes字节类型编码</li>
<li>内容示例<ul>
<li>英文：b’alex’</li>
<li>中文：b’\xe4\xb8\xad\xe5\x9b\xbd’</li>
</ul>
</li>
<li>组成单位：字节</li>
<li>bytes（特殊的字符类型，内部编码： 非unicode，比如：utf-8，gbk）：常用来存储到磁盘或者进行网络传输</li>
</ul>
</blockquote>
<h4 id="1-3-编码转换"><a href="#1-3-编码转换" class="headerlink" title="1.3 编码转换"></a>1.3 编码转换</h4><blockquote>
<ul>
<li>bytes类型也称作字节文本，他的主要用途就是网络的数据传输，与数据存储。那么有人问，bytes类型既然与str差不多，而且操作方法也很相似，就是在字符串前面加个b不就行了，python为什么还要这两个数据类型呢？我只用bytes不行么？<ul>
<li>str类型的数据想要存储到文件或者传输出去，那么直接是不可以的，需要将str数据转化成bytes数据就可以了</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>encode：<ul>
<li>编码，将 str 转化成 bytes类型</li>
<li>即unicode —编码—&gt; 非unicode（utf-8、gbk等）</li>
<li>然后进行存储到磁盘或者进行网络传输</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encode称作编码:将 str 转化成 bytes类型</span></span><br><span class="line">s1 = <span class="string">&#x27;中国&#x27;</span></span><br><span class="line">b1 = s1.encode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 转化成utf-8的bytes类型</span></span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># 中国</span></span><br><span class="line"><span class="built_in">print</span>(b1)  <span class="comment"># b&#x27;\xe4\xb8\xad\xe5\x9b\xbd&#x27;</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&#x27;中国&#x27;</span></span><br><span class="line">b1 = s1.encode(<span class="string">&#x27;gbk&#x27;</span>)  <span class="comment"># 转化成gbk的bytes类型</span></span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># 中国</span></span><br><span class="line"><span class="built_in">print</span>(b1)  <span class="comment"># b&#x27;\xd6\xd0\xb9\xfa&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>decode：<ul>
<li>解码，将bytes转化成str类型</li>
<li>即非unicode（utf-8、gbk等） —解码—&gt; unicode</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是utf-8编码bytes类型的中国,一个中文占了3个字节</span></span><br><span class="line">b1 =  <span class="string">b&#x27;\xe4\xb8\xad\xe5\x9b\xbd&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是gbk编码bytes类型的中国，一个中文占了2个字节</span></span><br><span class="line">b2 =  <span class="string">b&#x27;\xd6\xd0\xb9\xfa&#x27;</span>   </span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>不同编码方式的bytes如何相互转化<ul>
<li>不同编码方式之间不能直接相互转化，比如gbk-&gt;utf-8，但是可以间接的进行转化，使用unicode作为中间编码</li>
</ul>
</li>
<li>如何将gbk转化为utf-8编码的bytes呢？<ul>
<li>方法：可以借助unicode编码</li>
<li>过程：gbk(bytes类型)–&gt;解码–&gt;unicode–编码–&gt;utf-8(bytes类型)</li>
<li>unicode转换为bytes称为编码,也就是encode</li>
<li>bytes转化为unicode称为解码,也就是decode</li>
<li>需要遵循的一点，原始字节数据的编码格式是什么，编解码的格式就必须是什么格式</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是gbk编码bytes类型的&quot;中国&quot;，一个中文占了2个字节</span></span><br><span class="line">b1 = <span class="string">b&#x27;\xd6\xd0\xb9\xfa&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b1,<span class="built_in">type</span>(b1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将b1(bytes)--解码(decode)--&gt;unicode</span></span><br><span class="line">s = b1.decode(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s,<span class="built_in">type</span>(s)) <span class="comment"># s=中国，type(s)=&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将b1(unicode)--编码(encode)--&gt;utf-8(bytes)</span></span><br><span class="line">b2 = s.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b2,<span class="built_in">type</span>(b2)) <span class="comment"># b2=b&#x27;\xe4\xb8\xad\xe5\x9b\xbd&#x27; ,type(b2)=&lt;class &#x27;bytes&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9、运算符"><a href="#9、运算符" class="headerlink" title="9、运算符"></a>9、运算符</h3><h4 id="1-1-算数运算符"><a href="#1-1-算数运算符" class="headerlink" title="1.1 算数运算符"></a>1.1 算数运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增量赋值</span></span><br><span class="line">age += <span class="number">1</span> <span class="comment"># age = age + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉赋值</span></span><br><span class="line">x,y = y,x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链式赋值</span></span><br><span class="line">x,y,z = <span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压赋值</span></span><br><span class="line">x,y,*_,z = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment"># x = 1</span></span><br><span class="line"><span class="comment"># y = 2</span></span><br><span class="line"><span class="comment"># z = 6</span></span><br><span class="line"><span class="comment"># *_代表3,4,5这三个值</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-逻辑运算符"><a href="#1-2-逻辑运算符" class="headerlink" title="1.2 逻辑运算符"></a>1.2 逻辑运算符</h4><blockquote>
<p><code>not</code>  <code>and</code>  <code>or</code></p>
<p>优先级: not &gt; and &gt; or</p>
</blockquote>
<h4 id="1-3-成员运算符和身份运算符"><a href="#1-3-成员运算符和身份运算符" class="headerlink" title="1.3 成员运算符和身份运算符"></a>1.3 成员运算符和身份运算符</h4><blockquote>
<ul>
<li><p>成员运算符</p>
<ul>
<li><p>in </p>
<ul>
<li><p>判断元素是否存在于列表</p>
</li>
<li><p>&#96;&#96;&#96;python<br>111 in  [1,2,3,4,111]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 判断元素是否存在于字典，但是只能判断key，不能判断value</span><br><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  &quot;name&quot; in &#123;&quot;name&quot;:&quot;sam&quot;,age:18&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>not in</p>
<ul>
<li>判断元素不存在于列表</li>
</ul>
</li>
</ul>
</li>
<li><p>身份运算符</p>
<ul>
<li>is  判断两个值的内存地址是否相同</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="二、流程控制"><a href="#二、流程控制" class="headerlink" title="二、流程控制"></a>二、流程控制</h2><h3 id="1、if-else判断"><a href="#1、if-else判断" class="headerlink" title="1、if-else判断"></a>1、if-else判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">20</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;age 大于 20&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;age 小于 20&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2、if-elif-else判断"><a href="#2、if-elif-else判断" class="headerlink" title="2、if-elif-else判断"></a>2、if-elif-else判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">20</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;age 大于 20&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age == <span class="number">19</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;age 等于 20&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;age 小于 20&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3、for循环"><a href="#3、for循环" class="headerlink" title="3、for循环"></a>3、for循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure>

<img src="/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/image-20230217133254541.png" class="" title="image-20230217133254541">

<h3 id="4、while循环"><a href="#4、while循环" class="headerlink" title="4、while循环"></a>4、while循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> nums &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;num ==&gt; <span class="subst">&#123;nums&#125;</span>&quot;</span>)</span><br><span class="line">    nums -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<img src="/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/image-20230217133430162.png" class="" title="image-20230217133430162">

<h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><h3 id="1、为什么要用函数"><a href="#1、为什么要用函数" class="headerlink" title="1、为什么要用函数"></a>1、为什么要用函数</h3><p>1.1、先来看这样一个例子：自己实现Python内置的len方法</p>
<blockquote>
<p>len() 是python内置的方法，用来计算列表、元组、字符串的元素个数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;ilovepython&quot;</span></span><br><span class="line">count1 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s1:</span><br><span class="line">    count1 += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count1) <span class="comment"># count1=11</span></span><br><span class="line"></span><br><span class="line">s2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">count2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s2:</span><br><span class="line">    count2 += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(count2) <span class="comment"># count2=5</span></span><br></pre></td></tr></table></figure>

<p>1.2、使用for循环遍历字符串、列表、元组，然后使用一个count变量来递增统计循环的次数，循环结束也就拿到了字符串、列表、元素的元素个数，但只要计算一个字符串长度就要写一个for循环，代码被大量重复使用，我们肯定不希望这样来写代码，所以引入了函数概念</p>
<p>1.3、函数：以功能(完成一件事)为目的，比如登录、注册、len等等，一个函数就是一个功能，随调随用，减少了代码的重复性，增强了代码的可读性</p>
<p>1.4、将上述自己实现len方法写成函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">len_ly</span>(<span class="params">seqeue</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> seqeue:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;ilovepython&quot;</span></span><br><span class="line">s3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(len_ly(s)) <span class="comment"># 11</span></span><br><span class="line"><span class="built_in">print</span>(len_ly(s3)) <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p>1.5、名字叫len_ly的这个函数就实现随调随用</p>
<h3 id="2、函数的结构与调用"><a href="#2、函数的结构与调用" class="headerlink" title="2、函数的结构与调用"></a>2、函数的结构与调用</h3><p>2.1、函数的格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    结构：</span></span><br><span class="line"><span class="string">        def：关键字，定义函数，以冒号结束</span></span><br><span class="line"><span class="string">        test：函数名，与变量设置相同，具有描述性，</span></span><br><span class="line"><span class="string">        print(&quot;test func&quot;)：函数体，必须以4个空格缩进，函数中尽量不要出现print</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test func&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2.2、函数什么时候执行？</p>
<blockquote>
<p>函数名：指向的是函数的内存地址</p>
<p>当遇到  函数名+() ，函数才会被执行!!!，并且是从上到下依次执行函数里的所有内容</p>
</blockquote>
<h3 id="3、return函数的返回值"><a href="#3、return函数的返回值" class="headerlink" title="3、return函数的返回值"></a>3、return函数的返回值</h3><p>3.1、return的作用</p>
<blockquote>
<ol>
<li>return 用来将函数的值返回，在函数中遇到return会直接结束函数运行</li>
<li>return将数据返回给函数的执行者，执行者:函数名+() 表示运行函数</li>
<li>return单个元素时，以单个元素返回给函数的执行者</li>
<li>return多个元素时，是以元组形式返回给函数的执行者</li>
</ol>
</blockquote>
<p>3.2、代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">res = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;res=<span class="subst">&#123;res&#125;</span>&#x27;</span>) <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>

<p>3.3、return的其他注意点</p>
<blockquote>
<ol>
<li>函数里不写return，默认函数返回值就是None</li>
<li>函数里写了return，但是后面不跟任何元素，返回的是None，其实return作用就是终止函数</li>
</ol>
</blockquote>
<h3 id="4、形参、关键字参数、默认参数"><a href="#4、形参、关键字参数、默认参数" class="headerlink" title="4、形参、关键字参数、默认参数"></a>4、形参、关键字参数、默认参数</h3><p>4.1、函数的形参、实参</p>
<blockquote>
<p>形参：函数定义时接收的参数形式</p>
<p>实参：函数执行传的参数</p>
</blockquote>
<p>4.2、位置参数</p>
<blockquote>
<p>从左至右，一 一对应来传参</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">name,age,sex</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name=&quot;</span>,name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;age=&quot;</span>,age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sex=&quot;</span>,sex)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;xm&quot;</span>,<span class="number">18</span>,<span class="string">&quot;boy&quot;</span>)</span><br><span class="line"><span class="comment"># name= xm</span></span><br><span class="line"><span class="comment"># age= 18</span></span><br><span class="line"><span class="comment"># sex= man</span></span><br></pre></td></tr></table></figure>

<p>4.3、关键字参数</p>
<blockquote>
<p>以键值对的方式传参，传参的顺序可以打乱，但是必须参数名必须一 一对应</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">name,age,sex</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name=&quot;</span>,name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;age=&quot;</span>,age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sex=&quot;</span>,sex)</span><br><span class="line"></span><br><span class="line">test(name=<span class="string">&quot;xl&quot;</span>,age=<span class="number">28</span>,sex=<span class="string">&quot;girl&quot;</span>)</span><br><span class="line"><span class="comment"># #name= xl</span></span><br><span class="line"><span class="comment"># age= 28</span></span><br><span class="line"><span class="comment"># sex= girl</span></span><br></pre></td></tr></table></figure>

<p>4.4、默认参数</p>
<blockquote>
<p>给函数定义的形参设置一个值，作为默认值，有默认参数的函数在函数执行时可以不需要对默认参数进行传参，当然给默认参数传了参，会将默认参数的值覆盖掉</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">name,age,sex=<span class="string">&quot;man&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name=&quot;</span>,name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;age=&quot;</span>,age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sex=&quot;</span>,sex)</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;xm&quot;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># name= xm</span></span><br><span class="line"><span class="comment"># age= 18</span></span><br><span class="line"><span class="comment"># sex= man</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;xl&quot;</span>,<span class="number">28</span>,sex=<span class="string">&quot;girl&quot;</span>)</span><br><span class="line"><span class="comment"># #name= xl</span></span><br><span class="line"><span class="comment"># age= 28</span></span><br><span class="line"><span class="comment"># sex= girl</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.6、混合传参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">name,age,sex</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name=&quot;</span>,name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;age=&quot;</span>,age)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sex=&quot;</span>,sex)</span><br><span class="line"></span><br><span class="line">test(name=<span class="string">&quot;xm&quot;</span>,<span class="number">18</span>,sex=<span class="string">&quot;boy&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>4.7、混合传参的注意点</p>
<blockquote>
<p>对于混合传参(关键字参数和位置参数一起传参)，关键字参数一定要在位置参数的后面，则会报错</p>
</blockquote>
<h3 id="5、万能参数-args和-kwargs"><a href="#5、万能参数-args和-kwargs" class="headerlink" title="5、万能参数:*args和**kwargs"></a>5、万能参数:*args和**kwargs</h3><p>5.1、可以接收所有的实参，就是万能参数，也叫可变参数，比如: *args,**kwargs</p>
<p>5.2、*的魔法使用</p>
<blockquote>
<p>函数定义时： 代表聚合</p>
<p>合数调用时：代表打散</p>
</blockquote>
<p>5.3、*args：表示可以接收任意个数的位置参数，接收的参数之间以逗号隔开</p>
<blockquote>
<ol>
<li>args 约定成俗的叫法，换成其他名字也没有问题，只不过用的多了都叫这个名字</li>
<li>一个星号(*)表示聚合，将所有的位置参数聚合成一个元组，赋值给了args</li>
<li>传入一个列表进去会被当成元组的一个元素</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args=&quot;</span>,args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args type:&quot;</span>,<span class="built_in">type</span>(args))</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># args= (1, 2, 3)</span></span><br><span class="line"><span class="comment"># args type: &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">test([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) </span><br><span class="line"><span class="comment"># 传入一个列表进去会被当成元组的一个元素</span></span><br><span class="line"><span class="comment"># args= ([1, 2, 3],)</span></span><br><span class="line"><span class="comment"># args type: &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.4、**kwargs：</p>
<blockquote>
<ol>
<li>kwargs 约定成俗的叫法，换成其他名字也没有问题，只不过用的多了都叫这个名字</li>
<li>两个星号(**)表示聚合，将所有的关键字参数聚合成一个字典，赋值给了kwargs</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs=&quot;</span>,kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs type:&quot;</span>,<span class="built_in">type</span>(kwargs))</span><br><span class="line"></span><br><span class="line">test(sex=<span class="string">&quot;boy&quot;</span>,name=<span class="string">&quot;liming&quot;</span>)</span><br><span class="line"><span class="comment"># kwargs= &#123;&#x27;sex&#x27;: &#x27;boy&#x27;, &#x27;name&#x27;: &#x27;liming&#x27;&#125;</span></span><br><span class="line"><span class="comment"># kwargs type: &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.5、正向传参：*args和**kwargs混合使用，位置参数和关键字参数一 一传入到test函数就是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args=&quot;</span>,args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args type:&quot;</span>,<span class="built_in">type</span>(args))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs=&quot;</span>,kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs type:&quot;</span>,<span class="built_in">type</span>(kwargs))</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,sex=<span class="string">&quot;boy&quot;</span>,name=<span class="string">&quot;liming&quot;</span>)</span><br><span class="line"><span class="comment"># args= (1, 2, 3)</span></span><br><span class="line"><span class="comment"># args type: &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="comment"># kwargs= &#123;&#x27;sex&#x27;: &#x27;boy&#x27;, &#x27;name&#x27;: &#x27;liming&#x27;&#125;</span></span><br><span class="line"><span class="comment"># kwargs type: &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.6、逆向传参：在程序已有列表、元祖、字典等对象的前提下，把他们的元素拆开传给函数，逆向参数收集需要在传入的列表、元组参数之前添加一个星号 ，在字典参数之前添加两个星号，不管是一颗星还是两颗星都表示打散传入的参数所有元素，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args=&quot;</span>,args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args type:&quot;</span>,<span class="built_in">type</span>(args))</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">a = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">test1(*a)</span><br><span class="line"><span class="comment"># args= (4, 5, 6)</span></span><br><span class="line"><span class="comment"># args type: &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">test1(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># args= (1, 2, 3)</span></span><br><span class="line"><span class="comment"># args type: &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs=&quot;</span>,kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs type:&quot;</span>,<span class="built_in">type</span>(kwargs))</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">b=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lixiao&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">test2(**b)</span><br><span class="line"><span class="comment"># kwargs= &#123;&#x27;name&#x27;: &#x27;lixiao&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br><span class="line"><span class="comment"># kwargs type: &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line">    </span><br><span class="line">test2(**&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lixiao&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment"># kwargs= &#123;&#x27;name&#x27;: &#x27;lixiao&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br><span class="line"><span class="comment"># kwargs type: &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="6、函数的名称空间、作用域"><a href="#6、函数的名称空间、作用域" class="headerlink" title="6、函数的名称空间、作用域"></a>6、函数的名称空间、作用域</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jin-xin/articles/10839389.html">名称空间解释</a></p>
</blockquote>
<p>6.1、全局名称空间：</p>
<pre><code>     在python解释器开始执行之后, 就会在内存中开辟一个空间, 每当遇到一个变量的时候, 就把变量名和值之间的关系记录下来, 但是当遇到函数定义的时候, 解释器只是把函数名读入内存, 表示这个函数存在了, 至于函数内部的变量和逻辑, 解释器是不关心的. 也就是说一开始的时候函数只是加载进来, 仅此而已, 只有当函数被调用和访问的时候, 解释器才会根据函数内部声明的变量来进行开辟变量的内部空间. 随着函数执行完毕, 这些函数内部变量占用的空间也会随着函数执行完毕而被清空.
 
     我们首先回忆一下Python代码运行的时候遇到函数是怎么做的，从Python解释器开始执行之后，就在内存中开辟里一个空间，每当遇到一个变量的时候，就把变量名和值之间对应的关系记录下来，但是当遇到函数定义的时候，解释器只是象征性的将函数名读如内存，表示知道这个函数存在了，至于函数内部的变量和逻辑，解释器根本不关心。
 
     等执行到函数调用的时候，Python解释器会再开辟一块内存来储存这个函数里面的内容，这个时候，才关注函数里面有哪些变量，而函数中的变量回储存在新开辟出来的内存中，函数中的变量只能在函数内部使用，并且会随着函数执行完毕，这块内存中的所有内容也会被清空。
</code></pre>
<p>​		我们给这个‘存放名字与值的关系’的空间起了一个名字——-命名空间。</p>
<p>​		代码在运行伊始，创建的存储“变量名与值的关系”的空间叫做全局命名空间；</p>
<p>​		在函数的运行中开辟的临时的空间叫做局部命名空间也叫做临时名称空间。</p>
<p>​		现在我们知道了，py文件中，存放变量与值的关系的一个空间叫做全局名称空间，而当执行一个函数时，内存中会临时开辟一个空间，临时存放函数中的变量与值的关系，这个叫做临时名称空间，或者局部名称空间。</p>
<pre><code> 其实python还有一个空间叫做内置名称空间：内置名称空间存放的就是一些内置函数等拿来即用的特殊的变量：input，print，list等等，所以，我们通过画图捋一下：
</code></pre>
<img src="/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/1dbdb473-e660-4707-abc5-b3f4d0f80340-2885684.jpg" class="" title="img">

<p>那么这就是python中经常提到的三个空间。</p>
<p>6.2、总结:</p>
<blockquote>
<ol>
<li><p>全局命名空间–&gt; 我们直接在py文件中, 函数外声明的变量都属于全局命名空间</p>
</li>
<li><p>局部命名空间–&gt; 在函数中声明的变量会放在局部命名空间</p>
</li>
<li><p>内置命名空间–&gt; 存放python解释器为我们提供的名字, list, tuple, str, int这些都是内置命名空间</p>
</li>
</ol>
</blockquote>
<p>6.3、加载顺序：</p>
<pre><code>     所谓的加载顺序，就是这三个空间加载到内存的先后顺序，也就是这个三个空间在内存中创建的先后顺序，你想想他们能是同时创建么？肯定不是的，那么谁先谁后呢？我们捋顺一下：在启动python解释器之后，即使没有创建任何的变量或者函数，还是会有一些函数直接可以用的比如abs(-1),max(1,3)等等，在启动Python解释器的时候，就已经导入到内存当中供我们使用，所以肯定是先加载内置名称空间，然后就开始从文件的最上面向下一行一行执行，此时如果遇到了初始化变量，就会创建全局名称空间，将这些对应关系存放进去，然后遇到了函数执行时，在内存中临时开辟一个空间，加载函数中的一些变量等等。所以这三个空间的加载顺序为：内置命名空间(程序运行伊始加载)-&gt;全局命名空间(程序运行中：从上到下加载)-&gt;局部命名空间(程序运行中：调用时才加载。
</code></pre>
<p>6.4、取值顺序：</p>
<pre><code>     取值顺序就是引用一个变量，先从哪一个空间开始引用。这个有一个关键点：从哪个空间开始引用这个变量。我们分别举例说明：
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你在全局名称空间引用一个变量，先从全局名称空间引用，全局名# 称空间如果没有，才会向内置名称空间引用。</span></span><br><span class="line"><span class="built_in">input</span> = <span class="number">666</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>) <span class="comment"># 666</span></span><br><span class="line"><span class="comment"># 如果你在局部名称空间引用一个变量，先从局部名称空间引用，</span></span><br><span class="line"><span class="comment"># 局部名称空间如果没有，才会向全局名称空间引用，全局名称空间在没有，就会向内置名称空间引用。</span></span><br><span class="line"><span class="built_in">input</span> = <span class="number">666</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>) <span class="comment"># 666</span></span><br><span class="line"><span class="built_in">input</span> = <span class="number">666</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">input</span> = <span class="number">111</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">input</span>) <span class="comment"># 111</span></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>6.5、所以空间的取值顺序与加载顺序是相反的，取值顺序满足的就近原则，从小范围到大范围一层一层的逐步引用。</p>
<img src="/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/bef1149c-e624-4e26-883d-c335b426f6ed-2885684.jpg" class="" title="img">

<p>6.6、三个空间</p>
<p>6.7、作用域</p>
<ul>
<li>作用域代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    count = <span class="number">13</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">test() <span class="comment"># 13 </span></span><br><span class="line"><span class="built_in">print</span>(count)  <span class="comment">#12 </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>test函数内部的count属于局部作用域变量，虽然和test函数外部的全局作用域变量重名，但是因为所处的作用域不同，互相不影响，因为这两个是在不同的内存地址空间里</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经典作用域错误</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码运行会报错</p>
</li>
<li><p>解释如下</p>
<blockquote>
<p>局部作用域（比如函数内部）不能改变全局作用域的变量，但是可以引用，也就是在局部作用域里仅仅可以把全局作用域拿过来使用一下，但是不能改变全局作用域的变量</p>
<p>结论：当python解释器读取到局部作用域时，发现了你对一个变量进行修改的操作，解释器就会认为你再局部作用域已经定义过这个局部变量了，解释器就会从局部去找局部变量，但是没有找到（因为修改的是全局作用域变量），所以报错了</p>
</blockquote>
</li>
<li><p>先看一个简单例子</p>
</li>
<li><p>从上面可以看出，b是a的基础上+1，那么b和a的内存地址不一样，就表示a和b是两个变量，映射到函数中也是一样，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外层的num是全局变量</span></span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;外层num:<span class="subst">&#123;<span class="built_in">id</span>(num)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="comment"># 内层的num是在原来的基础上做了+1操作，那么就是一个新的值，指向新的内存地址，需要使用global声明num为全局变量，</span></span><br><span class="line">    <span class="comment"># 如果不声明，那就会在执行test函数时，找不到num这个局部变量，直接抛出异常</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;内层num:<span class="subst">&#123;<span class="built_in">id</span>(num)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#　外层alist和内层alist指向的是同一个内存地址空间，所以不需要使用global</span></span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;外层alist:<span class="subst">&#123;<span class="built_in">id</span>(alist)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    alist.append(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;内层alist:<span class="subst">&#123;<span class="built_in">id</span>(alist)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 但是内层alist是在alist基础上增加了一些值，那么alist就会指向新的内存地址，是一个新的列表</span></span><br><span class="line">    alist_1 = alist + [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;内层alist_1:<span class="subst">&#123;<span class="built_in">id</span>(alist_1)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">test1()</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结：</p>
<ul>
<li>在函数中，对于全局变量进行修改时，是否需要global进行说明，是要看是否对全局变量的执行指向进行了修改，也就是修改全局变量后是否指向了的内存地址（新值）</li>
<li>如果没有产生新值，那么就可以不用global声明，比如可变数据类型</li>
<li>如果修改了执行，即全局变量指向了一个新地址，那么必须用global来声明</li>
</ul>
</li>
</ul>
<h3 id="7、高阶函数"><a href="#7、高阶函数" class="headerlink" title="7、高阶函数"></a>7、高阶函数</h3><p>7.1、函数嵌套也就是高阶函数</p>
<h3 id="8、globals-和-locals"><a href="#8、globals-和-locals" class="headerlink" title="8、globals() 和 locals()"></a>8、globals() 和 locals()</h3><p>8.1、globals() 和 locals()的使用，这两个属于内置函数</p>
<blockquote>
<p>globals() :返回的是字典: 字典里面的键值对是全局作用域的所有内容</p>
<p>locals():返回的是字典: 字典里面的键值对是当前作用域的所有内容</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    name = <span class="string">&quot;tom&quot;</span></span><br><span class="line">    age=<span class="number">73</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">globals</span>())  <span class="comment"># 返回的是字典: 字典里面的键值对是全局作用域的所有内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># 返回的是字典: 字典里面的键值对是当前作用域的所有内容，也就是test函数这个作用域</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()) <span class="comment"># 返回的是字典: 字典里面的键值对是全局作用域的所有内容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">locals</span>())  <span class="comment"># 返回的是字典: 字典里面的键值对是当前作用域的所有内容，也就是全局作用域</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<h3 id="9、global关键字作用"><a href="#9、global关键字作用" class="headerlink" title="9、global关键字作用"></a>9、global关键字作用</h3><p>9.1、在局部作用域声明一个全局变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> name  <span class="comment"># 将局部作用域的name变量声明为全局作用域变量</span></span><br><span class="line">    name = <span class="string">&quot;tom&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name) <span class="comment"># 因为还没运行func函数，所以name变量还没有从局部作用域变为全局作用域变量，所以会报name is not defined错误</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()) <span class="comment"># 全局作用域内容中没有 name 字段</span></span><br><span class="line">func()  <span class="comment"># 遇到函数名+括号才算运行函数，此时函数里的global name才会生效变为全局作用域变量</span></span><br><span class="line"><span class="built_in">print</span>(name) <span class="comment"># 此时访问name已经变成了全局作用域变量了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()) <span class="comment"># 全局作用域内容中有了 name 字段</span></span><br></pre></td></tr></table></figure>

<p>9.2、修改一个全局变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(count) <span class="comment"># func函数还没运行，所以count还是1</span></span><br><span class="line">func()  <span class="comment"># func函数运行，count由局部作用域变量声明为了全局作用域变量，并且做了count = count + 1 计算，所以全局作用域变量count=2</span></span><br><span class="line"><span class="built_in">print</span>(count) <span class="comment"># 此时count已经变为2</span></span><br></pre></td></tr></table></figure>

<h3 id="10、nonlocal关键字-使用较少"><a href="#10、nonlocal关键字-使用较少" class="headerlink" title="10、nonlocal关键字(使用较少)"></a>10、nonlocal关键字(使用较少)</h3><p>10.1、不能操作全局变量，运行会报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">nonlocal</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">func() </span><br></pre></td></tr></table></figure>

<p>10.2、局部作用域：内部函数对外层函数的局部变量进行修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(count) <span class="comment"># func函数局部作用域里的count变量仍是1没变</span></span><br><span class="line">    inner() <span class="comment"># inner函数开始执行，并且inner函数使用nonlocal关键字，即inner函数对外层函数的局部变量count进行修改进行了+1</span></span><br><span class="line">    <span class="built_in">print</span>(count) <span class="comment"># 此时inner函数外层函数的count变量已经变成了2</span></span><br><span class="line"></span><br><span class="line">func() <span class="comment"># 结果1和2</span></span><br></pre></td></tr></table></figure>

<h3 id="11、默认参数、作用域的陷阱"><a href="#11、默认参数、作用域的陷阱" class="headerlink" title="11、默认参数、作用域的陷阱"></a>11、默认参数、作用域的陷阱</h3><p>11.1、默认参数的陷阱</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果默认参数指向的是可变数据类型，比如列表，那么无论调用多少次这个默认参数，都是同一个</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,alist=[]</span>):</span><br><span class="line">    alist.append(a)</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">10</span>)) <span class="comment"># [10]，只传了一个10进去，那么10就会传入默认参数这个空列表中</span></span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">20</span>,[])) <span class="comment">#[20],因为这个传参后面新传了一个空列表进去，那么20就会存到新的空列表中</span></span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">30</span>))  <span class="comment">#[10,30] 第三次调用，还是走默认参数的列表，但是因为第一次调用的时候已经将10传进去了，那么就会再把30传进去 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这三个函数是执行一个打印出一个结果</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果默认参数指向的是可变数据类型，比如列表，那么无论调用多少次这个默认参数，都是同一个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,alist=[]</span>):</span><br><span class="line">    alist.append(a)</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line">ret1 = func(<span class="number">10</span>) </span><br><span class="line">ret2 = func(<span class="number">20</span>,[])</span><br><span class="line">ret3 = func(<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 这里是上面三个函数都执行完了再打印，那么ret1的值在ret3执行完以后也变得和ret3一样了，因为ret1和ret3共用同一个列表</span></span><br><span class="line"><span class="built_in">print</span>(ret1) <span class="comment"># [10,30]</span></span><br><span class="line"><span class="built_in">print</span>(ret2) <span class="comment">#[20],</span></span><br><span class="line"><span class="built_in">print</span>(ret3)  <span class="comment">#[10,30] </span></span><br></pre></td></tr></table></figure>

<p>11.2、作用域的陷阱，同6里面的作用域</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count = <span class="number">3</span></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果</li>
</ul>
<blockquote>
<p> <code>local variable &#39;count&#39; referenced before assignment</code></p>
<p>这句话的意思: 局部变量在赋值前被引用</p>
<p><code>referenced </code>：引用</p>
<p><code>assignment</code>： 赋值</p>
</blockquote>
<ul>
<li>所以在函数中，如果定义了一个变量，但在定义这个变量之前就对其进行了引用，那么解释器在引用时去找这个变量没有找到就会报错，属于语法问题</li>
</ul>
<h3 id="12、函数名应用"><a href="#12、函数名应用" class="headerlink" title="12、函数名应用"></a>12、函数名应用</h3><p>12.1、函数名可以多次赋值引用</p>
<blockquote>
<p>函数名：就是一个变量，指向的是函数的内存地址</p>
<p>当遇到  函数名+() ，函数才会被执行!!!，并且是从上到下依次执行函数里的所有内容</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func) <span class="comment">#  func就是个变量，那么func这个变量的值指向的是函数的内存地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(func)) <span class="comment"># 函数类型</span></span><br><span class="line">func() <span class="comment"># 所以这里也可以理解为是函数的内存+()来运行函数，函数名就是个变量，可以取任意名字</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">10</span>,<span class="string">&quot;函数名重命名&quot;</span>,<span class="string">&quot;*&quot;</span>*<span class="number">10</span>)</span><br><span class="line">f = func</span><br><span class="line">f1 = f</span><br><span class="line">f2 = f1</span><br><span class="line">f2()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func1&quot;</span>)</span><br><span class="line"></span><br><span class="line">func1 = func <span class="comment"># 这里将func函数名重新指向了func1</span></span><br><span class="line"></span><br><span class="line">func1()  <span class="comment"># 这里执行func1执行的就是func函数</span></span><br></pre></td></tr></table></figure>

<p>12.2、函数名可以作为容器数据类型的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func2&quot;</span>)</span><br><span class="line"></span><br><span class="line">ll = [func,func1,func2]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ll:</span><br><span class="line">    i()</span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="keyword">in</span> func</span><br><span class="line"><span class="keyword">in</span> func1</span><br><span class="line"><span class="keyword">in</span> func2</span><br></pre></td></tr></table></figure>

<p>12.3、函数名可以作为函数的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">x</span>):  <span class="comment"># x = func</span></span><br><span class="line">    x()   <span class="comment"># 这里执行的就是func()，</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func1&quot;</span>) </span><br><span class="line"></span><br><span class="line">func1(func)  <span class="comment"># 将func函数名作为参数传给func1函数，先输出 in func，再输出 in func1</span></span><br></pre></td></tr></table></figure>

<p>12.4、函数名作为函数的返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">x</span>):  <span class="comment"># x = func</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func1&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">ret = func1(func) <span class="comment"># ret的值就是func1函数传进去的func这个形参</span></span><br><span class="line">ret() <span class="comment"># ret()执行的就是func()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13、闭包函数"><a href="#13、闭包函数" class="headerlink" title="13、闭包函数"></a>13、闭包函数</h3><h4 id="1-1-什么是闭包"><a href="#1-1-什么是闭包" class="headerlink" title="1.1 什么是闭包"></a>1.1 什么是闭包</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jin-xin/articles/10863032.html">https://www.cnblogs.com/jin-xin/articles/10863032.html</a></p>
</blockquote>
<h5 id="1-1-1-新复习闭包函数"><a href="#1-1-1-新复习闭包函数" class="headerlink" title="1.1.1 新复习闭包函数"></a>1.1.1 新复习闭包函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;x--<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2024年09月26日11:02:58 复习重新理解闭包</p>
<ul>
<li>一、大前提：<ul>
<li>闭包函数&#x3D;名称空间与作用于+函数嵌套+函数对象</li>
<li>核心点：名字的查找关系是以函数定义阶段为准</li>
</ul>
</li>
<li>二、什么是闭包函数（以上面的代码为例）<ul>
<li>“闭”函数是指的该f2函数是内嵌函数</li>
<li>“包”函数是值该f2函数对外层f1函数作用域名字的引用（不是对全局作用域）<ul>
<li>也就是说x这个值不能在f2内部，但是必须在f1函数内部，</li>
<li>当x在f1外部时，那x就是全局变量，那f1就不是闭包了</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="1-1-2-历史复习"><a href="#1-1-2-历史复习" class="headerlink" title="1.1.2 历史复习"></a>1.1.2 历史复习</h5><blockquote>
<ul>
<li>闭包定义<ul>
<li>闭包函数只能存在嵌套函数</li>
<li>内层函数对外层函数的非全局变量的引用(使用)，就会形成闭包</li>
<li>被引用的非全局变量也叫自由变量，这个自由变量会和内层函数产生一个绑定关系</li>
<li>自由变量持续在内存中存在，不会消失，可以持续调用</li>
</ul>
</li>
<li>闭包的作用<ul>
<li>保存局部信息不被销毁，保证数据的安全性。</li>
</ul>
</li>
<li>闭包的应用<ul>
<li>可以保存一些非全局变量但是不易被销毁、改变的数据。</li>
<li>装饰器</li>
</ul>
</li>
<li>如何判断一个嵌套函数是不是闭包<ul>
<li>闭包是嵌套在函数中的函数</li>
<li>闭包必须是内层函数对外层函数的变量（非全局变量）的引用。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li>上面被红色方框框起来的区域就是闭包，被蓝色圈起来的那个变量应该是make_averager()函数的局部变量，它应该是随着make_averager()函数的执行结束之后而消失。</li>
<li>但是他没有，是因为此区域形成了闭包，series变量就变成了一个叫自由变量的东西，averager函数的作用域会延伸到包含自由变量series的绑定。</li>
<li>也就是说，每次我调用avg对应的averager函数 时，都可以引用到这个自由变量series，这个就是闭包。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例一：是闭包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper1</span>():</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">ret1 = wrapper1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例二：不是闭包，因为a1是全局变量</span></span><br><span class="line">a1 = <span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper2</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(a1)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">ret2 = wrapper2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例三：是闭包</span></span><br><span class="line"><span class="comment"># 因为a，b是作为参数传进wrapper3函数中，那么a,b就是wrapper3函数里的局部变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper3</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">a2 = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">ret3 = wrapper3(a2,b)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-判断函数是不是闭包"><a href="#1-2-判断函数是不是闭包" class="headerlink" title="1.2 判断函数是不是闭包"></a>1.2 判断函数是不是闭包</h4><blockquote>
<p>使用<code>func.__code__.co_freevars</code>来判断，有返回值就是闭包，没有就不是</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例二：不是闭包，因为a1是全局变量</span></span><br><span class="line">a1 = <span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper2</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(a1)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">ret2 = wrapper2()</span><br><span class="line"><span class="built_in">print</span>(ret2.__code__.co_freevars) <span class="comment"># ()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="14、格式化输出"><a href="#14、格式化输出" class="headerlink" title="14、格式化输出"></a>14、格式化输出</h3><p>14.1 %s、format格式化输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">msg1 = <span class="string">&#x27;My name is %s, %s years old&#x27;</span> %(name,age)</span><br><span class="line">msg2 = <span class="string">&#x27;My name is &#123;0&#125;, &#123;1&#125; years old&#x27;</span>.<span class="built_in">format</span>(name,age)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(msg1)</span><br><span class="line"><span class="built_in">print</span>(msg2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">My name <span class="keyword">is</span> Tom, <span class="number">18</span> years old</span><br><span class="line">My name <span class="keyword">is</span> Tom, <span class="number">18</span> years old</span><br></pre></td></tr></table></figure>

<p>14.2 f-string 格式化输出</p>
<blockquote>
<p>Python3.6以后支持的语法，效率更高</p>
<p>注意  ！， ：{  } ; 这些不能出现f-string的{}中</p>
<p>优点:</p>
<p>1、结构更简化</p>
<p>2、结合表达式、函数进行使用</p>
<p>3、比%s、format效率更高</p>
</blockquote>
<p>2.1、基本用法，格式化输出</p>
<blockquote>
<p>在需要格式化的前面加一个f&#x2F;F，大小写都支持</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;tom&quot;</span></span><br><span class="line">age = <span class="number">10</span></span><br><span class="line">msg = <span class="string">f&#x27;my name is <span class="subst">&#123;name&#125;</span> , I\&#x27;m <span class="subst">&#123;age&#125;</span> years old&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure>

<p>2.2、支持多种格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持表达式</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br><span class="line">msg = <span class="string">f&#x27;My name is <span class="subst">&#123;<span class="built_in">dict</span>[<span class="string">&quot;name&quot;</span>]&#125;</span>, <span class="subst">&#123;<span class="built_in">dict</span>[<span class="string">&quot;age&quot;</span>]&#125;</span> years old&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持计算</span></span><br><span class="line">count = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;count平方是: <span class="subst">&#123;count**<span class="number">2</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持字符串操作</span></span><br><span class="line">name = <span class="string">&quot;sam&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Name is: <span class="subst">&#123;name.upper()&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合函数写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;3 + 4 = <span class="subst">&#123;add(<span class="number">3</span>,<span class="number">4</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="15、函数的类型提示"><a href="#15、函数的类型提示" class="headerlink" title="15、函数的类型提示"></a>15、函数的类型提示</h3><blockquote>
<p>类型提示 Type hinting（最低Python版本3.5）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 形参后面加 冒号和类型,代表提示形参的提示信息</span></span><br><span class="line"><span class="comment"># -&gt;int 表示函数返回值，</span></span><br><span class="line"><span class="comment"># 上面两种提示信息传任何内容都可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">name:<span class="built_in">str</span>,age:<span class="built_in">int</span>,hobbies:<span class="built_in">tuple</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line">    <span class="built_in">print</span>(hobbies)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看提示信息的所有内容</span></span><br><span class="line"><span class="built_in">print</span>(register.__annotations__) <span class="comment">#&#123;&#x27;name&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;age&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;hobbies&#x27;: &lt;class &#x27;tuple&#x27;&gt;, &#x27;return&#x27;: &lt;class &#x27;int&#x27;&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、Python内置语法使用"><a href="#四、Python内置语法使用" class="headerlink" title="四、Python内置语法使用"></a>四、Python内置语法使用</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jin-xin/articles/10854130.html">https://www.cnblogs.com/jin-xin/articles/10854130.html</a></p>
</blockquote>
<h3 id="1、三元运算符"><a href="#1、三元运算符" class="headerlink" title="1、三元运算符"></a>1、三元运算符</h3><blockquote>
<p>1.简单的if…else语句</p>
<p>2.下图中的if条件为真输出die，if条件为假执行else，输出live</p>
</blockquote>
<h3 id="2、迭代器"><a href="#2、迭代器" class="headerlink" title="2、迭代器"></a>2、迭代器</h3><p>1.1 可迭代对象</p>
<blockquote>
<p>字面意思：Python中一切皆对象，一个实实在在存在的值，对象</p>
<p>可迭代：更新迭代，重复循环的过程，每次更新迭代都有新内容，可以进行循环更新的一个值</p>
<p>专业角度：内部含有一个<code>__iter__</code>方法的对象，可迭代对象</p>
<p>目前已有的可迭代对象：str&#x2F;list&#x2F;dict&#x2F;set&#x2F;range</p>
<p>优点：</p>
<p>​	1.存储的数据能直接展示，比较直观</p>
<p>​	2.拥有的方法比较多，操作方便</p>
<p>缺点：</p>
<p>​	1.占用内存</p>
<p>​	2.不能直接通过for循环，不能通过索引、key取值</p>
</blockquote>
<p>1.2 判断是否为可迭代对象</p>
<blockquote>
<p>获取对象的所有方法，以字符串形式表现，使用dir(obj)，返回值为一个列表</p>
<p>所有只要判断对象的所有方法里有<code>__iter__</code>方法，那就是可迭代对象</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__iter__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(s1)) <span class="comment"># true，那s1就是一个可迭代对象</span></span><br></pre></td></tr></table></figure>



<p>1.3 迭代器</p>
<blockquote>
<p>字面意思：更新迭代，器：工具，可迭代更新的工具</p>
<p>专业角度：内部含有<code>__iter__</code>方法并含有<code>__next__</code>方法的对象就是迭代器</p>
</blockquote>
<p>1.3.1 可以判断是否为迭代器：含有<code>__iter__</code>和<code>__next__</code>在不在dir(obj)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="string">&quot;article.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>((<span class="string">&quot;__iter__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(f)) <span class="keyword">and</span> <span class="string">&quot;__next__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(f))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>1.3.2 可迭代对象可以转换为迭代器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;echo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可迭代器对象转换为迭代器，原来的对象仍没有变化</span></span><br><span class="line"><span class="comment"># 两种方法：</span></span><br><span class="line"><span class="comment">#   1、iter(s)</span></span><br><span class="line"><span class="comment">#   2、s.__iter__()</span></span><br><span class="line">obj = <span class="built_in">iter</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代器返回值:&lt;str_iterator object at 0x00000000021283C8&gt;，表示字符串迭代器对象</span></span><br><span class="line"><span class="built_in">print</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取迭代器的值，当取值超过迭代器所有值以后，就抛出StopIteration报错</span></span><br><span class="line"><span class="comment"># obj这个迭代器只有&quot;e c h o&quot;四个元素，第五个next(obj)就会抛出StopIteration</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj)) <span class="comment"># 一个next即使运行N次，永远只会输出一个值，</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br></pre></td></tr></table></figure>

<p>1.3.3 迭代器优点</p>
<blockquote>
<p>1、节省内存：迭代器在内存中相当于只占一个数据的空间：因为每次取值都上一条数据会在内存释放（消失），加载当前的此条数据。</p>
<p>2、惰性机制：next一次，取一个值，绝不过多取值。​</p>
<p>3、有一个迭代器模式可以很好的解释上面这两条：迭代是数据处理的基石。扫描内存中放不下的数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项。这就是迭代器模式。</p>
<p>​    </p>
</blockquote>
<p>1.3.4 迭代器的缺点：</p>
<blockquote>
<p>1、不能直观的查看里面的数据。</p>
<p>2、速度慢</p>
<p>3、取值时不走回头路，只能一直向下取值。</p>
</blockquote>
<p>1.4 迭代器与可迭代对象的对比</p>
<blockquote>
<p>可迭代对象</p>
<p>​	是一个操作昂发比较多，比较直观、存储数据相对少（几百万个对象，8G内存可以承受）的一个数据集合</p>
<p>​	当侧重于数据可以灵活处理，并且内存空间足够，可以将数据集设置为可迭代对象</p>
<p>​	是一个非常节省内存，可记录取值位置，可以直接通过循环+next方法取值，但是不直观，操作方法比较单一的数据集合</p>
<p>迭代器：</p>
<p>​	当数据量非常大，足以撑爆内存或者为了节省内存时，将数据集设置为迭代器最好了</p>
</blockquote>
<p>1.5 for循环原理</p>
<blockquote>
<p>for循环原理：先将可迭代对象转换为迭代器，再调用迭代器的next方法进行取值</p>
</blockquote>
<p>1.5.1 使用while模拟for循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ll = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">11</span>,<span class="number">221</span>,<span class="number">34</span>]</span><br><span class="line">obj = ll.__iter__()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(obj))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h3 id="3、生成器"><a href="#3、生成器" class="headerlink" title="3、生成器"></a>3、生成器</h3><p>3.1 生成器</p>
<blockquote>
<ol>
<li>生成器本质就是迭代器</li>
<li>唯一区别：<ul>
<li>生成器是我们自己用python代码构建的数据结构</li>
<li>迭代器是提供的，或者转化而来的</li>
</ul>
</li>
</ol>
</blockquote>
<p>3.2 获取生成器的三种方式</p>
<blockquote>
<ol>
<li>生成器幻术</li>
<li>生成器表达式</li>
<li>python内部提供的一些</li>
</ol>
</blockquote>
<p>3.3 生成器函数获取生成器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成器函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">111</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">222</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span> <span class="comment"># 当运行生成器函数，只有一个next函数来取值时，只会执行到这里，下面的代码不会执行</span></span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">7</span> <span class="comment"># 当有两个next函数来取值时，会执行到这里</span></span><br><span class="line"></span><br><span class="line">ret = func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ret是一个生成器对象：&lt;generator object func at 0x000000000BB648E0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器通过next来取值，一个next对应一个yield</span></span><br><span class="line"><span class="comment"># 当next取值超过yield的范围，也会报Stopiteration错误，和迭代器一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(ret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># yield from seq </span></span><br><span class="line"><span class="comment"># 表示将这个可迭代对象中每一个元素变成了迭代器结果返回</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将alist这个列表变成了迭代器</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> alist</span><br><span class="line"></span><br><span class="line">ret = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(ret))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(ret))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(ret))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(ret))</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>return：</p>
</li>
<li><p>函数中只存在一个return结束函数，并给函数的执行者返回值</p>
</li>
<li><p>yield：</p>
<ul>
<li>只要函数中有yield，那就是生成器函数，而不是函数</li>
</ul>
</li>
<li><p>生成器函数中可以存在多个yield，一个yield对应一个next，yield不会结束函数</p>
</li>
</ul>
</blockquote>
<h3 id="4、推导式"><a href="#4、推导式" class="headerlink" title="4、推导式"></a>4、推导式</h3><p>4.1 列表推导式：多层嵌套循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取出所有人名有一个l的并大写</span></span><br><span class="line"></span><br><span class="line">l1 = [[<span class="string">&quot;sam&quot;</span>,<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;july&quot;</span>],[<span class="string">&quot;john&quot;</span>,<span class="string">&quot;lily&quot;</span>,<span class="string">&quot;wisely&quot;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 老办法</span></span><br><span class="line">l2 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> l1:</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> ele:</span><br><span class="line">        <span class="keyword">if</span> name.count(<span class="string">&quot;l&quot;</span>) == <span class="number">1</span>:</span><br><span class="line">            l2.append(name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;l2=<span class="subst">&#123;l2&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行代码,循环嵌套</span></span><br><span class="line">l3 = [name <span class="keyword">for</span> ele <span class="keyword">in</span> l1 <span class="keyword">for</span> name <span class="keyword">in</span> ele <span class="keyword">if</span> name.count(<span class="string">&quot;l&quot;</span>) == <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;l3=<span class="subst">&#123;l3&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>4.2 生成器推导式</p>
<blockquote>
<ul>
<li>与列表推导式的写法完全一致，也有筛选模式，循环模式，多层循环</li>
<li>唯一区别就是 [] 换成 ()</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj = ( i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(obj,<span class="built_in">type</span>(obj)) <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x0000000002856E60&gt; &lt;class &#x27;generator&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj)) <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj)) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(obj)) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p>4.3 总结</p>
<blockquote>
<ul>
<li><p>列表推导式：</p>
<ul>
<li><p>缺点：</p>
<ul>
<li>构建比较复杂且有规律的列表，不能太沉迷使用该办法</li>
<li>超过三层才能构建成功的，不要使用推导式</li>
<li>查找错误不方便，debug代码时</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
</li>
<li><p>一行代码构建，简单</p>
</li>
<li><p>列表推导式和生成器的区别</p>
<ul>
<li>写法：列表推导式[]，生成器语法 ()</li>
<li>列表是iterable，可迭代对象 </li>
<li>生成器的本质是迭代器(iterator)</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行代码构建[2, 3, 4, 5, 6, 7, 8, 9, 10, &#x27;J&#x27;, &#x27;Q&#x27;, &#x27;K&#x27;, &#x27;O&#x27;]</span></span><br><span class="line">ll = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">&quot;JQKO&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ll)</span><br></pre></td></tr></table></figure>

<h3 id="5、装饰器"><a href="#5、装饰器" class="headerlink" title="5、装饰器"></a>5、装饰器</h3><blockquote>
<p>装饰器等于高阶函数+闭包</p>
</blockquote>
<h3 id="6、模块导入import"><a href="#6、模块导入import" class="headerlink" title="6、模块导入import"></a>6、模块导入import</h3><p>6.1 模块</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109127048">https://zhuanlan.zhihu.com/p/109127048</a></p>
<blockquote>
<p>在Python中，一个py文件就是一个模块，文件名为xxx.py模块名则是xxx,</p>
</blockquote>
<p>6.2 导入模块发生了什么</p>
<blockquote>
<p>首次导入模块会发生3件事</p>
<ul>
<li><p>执行导入的文件（xx.py）</p>
</li>
<li><p>产生xx.py的名称空间，将xx.py运行过程中产生的名字都堆到foo的名称空间</p>
</li>
<li><p>在当前文件中产生的又一个名字xx，该名字指向2中产生的名称空间</p>
</li>
</ul>
<p>需要强调一点是，第一次导入模块已经将其加载到内存空间了，之后的重复导入会直接引用内存中已存在的模块，不会重复执行文件，通过import sys，打印sys.modules的值可以看到内存中已经加载的模块名。</p>
</blockquote>
<p>6.3 导入模块后引用</p>
<blockquote>
<p>强调1：</p>
<ul>
<li>方式：模块名.名字</li>
<li>是指名道姓问某个模块要名字对应的值，不会与当前名称空间中的名字发生冲突，即使是重名的</li>
</ul>
<p>强调2：</p>
<ul>
<li>无论是查看或修改，都是以调入的模块为基准，与调用位置无关，也就是说在一个文件里调用另外一个模块，无论对文件中定义或修改与调用模块同名的变量，不会对调用模块产生影响</li>
</ul>
</blockquote>
<p>6.4 起别名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  time <span class="keyword">as</span> t</span><br></pre></td></tr></table></figure>

<p>6.5 模块命名风格</p>
<blockquote>
<p>python3自定义模块的命名都是以纯消息+下划线风格</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br></pre></td></tr></table></figure>

<p>6.6  模块导入和代码测试</p>
<blockquote>
<p>1、一个Python文件有两种用途，</p>
<ul>
<li><p>一种被当主程序&#x2F;脚本执行，</p>
</li>
<li><p>另一种被当模块导入，</p>
</li>
</ul>
<p>2、为了区别同一个文件的不同用途，每个py文件都内置了<code>__name__</code>变量</p>
<ul>
<li>该变量在py文件被当做脚本执行时赋值为<code>“__main__”</code></li>
<li>在py文件被当做模块导入时赋值为模块名</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hahaha&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<p>6.7 from…import… 导入模块</p>
<blockquote>
<p>from…import…与import语句基本一致，唯一不同的是：使用import foo导入模块后，引用模块中的名字都需要加上foo.作为前缀，而使用from foo import x,get,change, foo则可以在当前执行文件中直接引用模块foo中的名字，如下</p>
<p>from xx import yy : yy必须是xx模块（xx.py文件）里的方法、变量、类等内容，import yy的yy是指向xx模块里叫yy这个方法的内存地址</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> x,get,change <span class="comment">#将模块foo中的x和get导入到当前名称空间</span></span><br><span class="line">a=x <span class="comment">#直接使用模块foo中的x赋值给a</span></span><br><span class="line">get() <span class="comment">#直接执行foo中的get函数</span></span><br><span class="line">change() <span class="comment">#即便是当前有重名的x，修改的仍然是源文件中的x</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>无需加前缀的好处是使得我们的代码更加简洁，坏处则是容易与当前名称空间中的名字冲突，如果当前名称空间存在相同的名字，则后定义的名字会覆盖之前定义的名字。</p>
</blockquote>
<blockquote>
<p>另外from语句支持<code>from foo import *</code>语法，*代表将foo中所有的名字都导入到当前位置</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> * <span class="comment">#把foo中所有的名字都导入到当前执行文件的名称空间中，在当前位置直接可以使用这些名字</span></span><br><span class="line"></span><br><span class="line">a=x</span><br><span class="line">get()</span><br><span class="line">change()</span><br><span class="line">obj=Foo()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们需要引用模块中的名字过多的话，可以采用上述的导入形式来达到节省代码量的效果，但是需要强调的一点是：只能在模块最顶层使用<em>的方式导入，在函数内则非法，并且</em>的方式会带来一种副作用，即我们无法搞清楚究竟从源文件中导入了哪些名字到当前位置，这极有可能与当前位置的名字产生冲突。模块的编写者可以在自己的文件中定义<code>__all__</code>变量用来控制*代表的意思</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#foo.py</span></span><br><span class="line">__all__=[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;get&#x27;</span>] <span class="comment">#该列表中所有的元素必须是字符串类型，每个元素对应foo.py中的一个名字</span></span><br><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;from the func&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样我们在另外一个文件中使用*导入时，就只能导入<code>__all__</code>定义的名字了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> * <span class="comment">#此时的*只代表x和get</span></span><br><span class="line"></span><br><span class="line">x <span class="comment">#可用</span></span><br><span class="line">get() <span class="comment">#可用</span></span><br><span class="line">change() <span class="comment">#不可用</span></span><br><span class="line">Foo() <span class="comment">#不可用</span></span><br></pre></td></tr></table></figure>

<p>6.8 模块跨目录导入</p>
<blockquote>
<p>模块查找优先级</p>
<ol>
<li>先从内存中找，内容中会预先加载Python的内置模块</li>
<li>如果内存中没有，就按照sys.path中存放的文件顺序依次查找所需要的导入的模块</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 值为一个列表，存放了一系列的文件夹</span></span><br><span class="line"><span class="comment"># 其中第一个文件夹是当前执行文件所在的文件夹</span></span><br><span class="line"><span class="comment"># 在pycharm中会看到项目的目录也会加到这个列表中，这是pycharm做的优化，真正Python解释器运行时不会有这个目录</span></span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看加载到内存中的模块</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sys.modules)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sys.path中的第一个路径通常为空，代表执行文件所在的路径，所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的，而针对被导入的模块与执行文件在不同路径下的情况，为了确保模块对应的源文件仍可以被找到，需要将源文件foo.py所在的路径添加到sys.path中，假设foo.py所在的路径为&#x2F;pythoner&#x2F;projects&#x2F;</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 找foo.py就把foo.py的文件夹添加到环境变量中</span></span><br><span class="line">sys.path.append(<span class="string">r&#x27;/pythoner/projects/&#x27;</span>) <span class="comment">#也可以使用sys.path.insert(……)，不过不推荐使用insert</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="comment">#无论foo.py在何处,我们都可以导入它了</span></span><br></pre></td></tr></table></figure>

<p>6.9 编写规范模块</p>
<blockquote>
<p>在编写py文件时，需要时刻提醒自己，该文件既是给自己用的，也有可能会被其他人使用，因而代码的可读性与易维护性显得十分重要，为此我们在编写一个模块时最好按照统一的规范去编写，如下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python #通常只在类unix环境有效,作用是可以使用脚本名来执行，而无需直接调用解释器。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;The module is used to...&quot;</span> <span class="comment">#模块的文档描述</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment">#导入模块</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span> <span class="comment">#定义全局变量,如果非必须,则最好使用局部变量,这样可以提高代码的易维护性,并且可以节省内存提高性能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>: <span class="comment">#定义类,并写好类的注释</span></span><br><span class="line">    <span class="string">&#x27;Class Foo is used to...&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(): <span class="comment">#定义函数,并写好函数的注释</span></span><br><span class="line">    <span class="string">&#x27;Function test is used to…&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment">#主程序</span></span><br><span class="line">    test() <span class="comment">#在被当做脚本执行时,执行此处的代码</span></span><br></pre></td></tr></table></figure>

<h3 id="7、模块和包"><a href="#7、模块和包" class="headerlink" title="7、模块和包"></a>7、模块和包</h3><h4 id="1-1-模块"><a href="#1-1-模块" class="headerlink" title="1.1 模块"></a>1.1 模块</h4><blockquote>
<p>模块就是一系列功能的集合体</p>
<ul>
<li><p>模块的作用：可以直接使用别人封装好的模块，提高开发效率</p>
</li>
<li><p>模块的三大类</p>
<ul>
<li><p>内置模块</p>
</li>
<li><p>第三方模块</p>
</li>
<li><p>自定义的模块</p>
<ul>
<li>一个python文件本身就是一个模块，文件名叫x.py，模块名叫m</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="7-2-模块导入"><a href="#7-2-模块导入" class="headerlink" title="7.2 模块导入"></a>7.2 模块导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="keyword">import</span> 模块名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意：</p>
<ul>
<li><p>import第一次导入时，会执行导入的文件中所有的代码</p>
</li>
<li><p>之后再重复导入，会直接引用第一次导入的名称空间，不会再次导入</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>从下图代码结果可以看出，import一个模块，其实就是在执行模块里的代码</p>
</blockquote>
<img src="/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/image-20221106003856637.png" class="" title="image-20221106003856637">

<blockquote>
<p>模块强调：</p>
<p>模块名.名字：表示指名道姓的访问某一个模块的对应变量的值</p>
<p>无论查看还是修改的都是模块本身，和调用位置无关</p>
</blockquote>
<h4 id="7-3-导入模块规范"><a href="#7-3-导入模块规范" class="headerlink" title="7.3 导入模块规范"></a>7.3 导入模块规范</h4><blockquote>
<p>先导入内置模块</p>
<p>其次导入第三方模块</p>
<p>最后导入自定义的模块</p>
</blockquote>
<blockquote>
<p>模块的起名python3中是纯小写+下划线的风格</p>
</blockquote>
<h4 id="7-4-模块导入起别名"><a href="#7-4-模块导入起别名" class="headerlink" title="7.4 模块导入起别名"></a>7.4 模块导入起别名</h4><blockquote>
<p>可以给导入的模块起个别名，使用<code>as</code>关键字来起别名</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx <span class="keyword">as</span> xl</span><br></pre></td></tr></table></figure>



<h2 id="五、常用模块"><a href="#五、常用模块" class="headerlink" title="五、常用模块"></a>五、常用模块</h2><h3 id="1、OS模块"><a href="#1、OS模块" class="headerlink" title="1、OS模块"></a>1、OS模块</h3><blockquote>
<p>和操作系统相关的操作封装在这个模块</p>
</blockquote>
<p>1.1. 和文件操作相关</p>
<blockquote>
<p>可以操作文件的重命名，删除等</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 这个文件不存在，临时写的一个不存在的文件名</span></span><br><span class="line">file = <span class="string">&quot;aaa&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 当文件不存在，执行会报错，FileNotFoundError: [WinError 2] 系统找不到指定的文件。: &#x27;aaa&#x27;</span></span><br><span class="line">os.remove(file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当文件不存在，执行会报错，FileNotFoundError: [WinError 2] 系统找不到指定的文件。: &#x27;aaa&#x27; -&gt; &#x27;bb.txt&#x27;</span></span><br><span class="line">os.rename(file,<span class="string">&quot;bb.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># 删除目录，目录可以是非空的</span></span><br><span class="line">shutil.rmtree(file)</span><br></pre></td></tr></table></figure>

<p>1.2. 和路径相关的操作</p>
<blockquote>
<p>和路径相关的操作，封装在一个子模块里：<code>os.path </code></p>
</blockquote>
<p>1.2.1 <code>os.path.dirname</code>：获取当前文件所在的目录</p>
<blockquote>
<p>不判断路径是否存在，即使路径不存在，返回值为空</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">file = <span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">s = os.path.dirname(file)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s=&quot;</span>,s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s len:&quot;</span>,<span class="built_in">len</span>(s))</span><br></pre></td></tr></table></figure>

<p>1.2.2 <code>os.path.basename</code>：获取当前路径的文件名</p>
<blockquote>
<p>不判断路径是否存在，即使路径不存在，也会返回文件名</p>
</blockquote>
<p>1.2.3  <code>os.path.split</code></p>
<blockquote>
<p>把路径中的路径名和文件名切分开，结果是元祖</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">file = <span class="string">&quot;./test/asfsd&quot;</span></span><br><span class="line"></span><br><span class="line">s = os.path.split(file)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s=&quot;</span>,s) <span class="comment"># s= (&#x27;./test&#x27;, &#x27;asfsd&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s len:&quot;</span>,<span class="built_in">len</span>(s)) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<p>1.2.4 <code>os.path.join</code>：拼接路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file = <span class="string">&quot;.\\test\\asfsd&quot;</span></span><br><span class="line"></span><br><span class="line">s = os.path.join(file,<span class="string">&quot;index.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s=&quot;</span>,s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s len:&quot;</span>,<span class="built_in">len</span>(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">s= .\test\asfsd\index.txt</span><br><span class="line">s <span class="built_in">len</span>: <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>1.2.5 <code>os.path.abspath</code></p>
<blockquote>
<p>1.如果是&#x2F;开头，默认是在当前盘符下</p>
<p>2.如果不以&#x2F;开头，默认是当前所在路径</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">s1 = os.path.abspath(<span class="string">r&quot;/a/b/c&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s1=&quot;</span>,s1)</span><br><span class="line"><span class="comment"># s1= D:\a\b\c</span></span><br><span class="line"></span><br><span class="line">s2 = os.path.abspath(<span class="string">r&quot;a/b/c&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s2=&quot;</span>,s2) </span><br><span class="line"><span class="comment"># 因为当前py文件所在目录就是D:\Flask\AutoCrossFire</span></span><br><span class="line"><span class="comment"># s2= D:\Flask\AutoCrossFire\a\b\c</span></span><br></pre></td></tr></table></figure>

<p>1.2.6 <code>os.path.exists</code></p>
<blockquote>
<p>判断文件是否存在，如果不存在，则返回值为False，否则为True</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">file = <span class="string">&quot;index.html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(file):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;file&#125;</span> exists&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;file&#125;</span> not exists&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">index.html <span class="keyword">not</span> exists</span><br></pre></td></tr></table></figure>



<h3 id="2、SYS模块"><a href="#2、SYS模块" class="headerlink" title="2、SYS模块"></a>2、SYS模块</h3><blockquote>
<p>和Python解释器相关的操作</p>
</blockquote>
<p>2.1 <code> sys.argv</code></p>
<blockquote>
<p>获取命令行方式运行的脚本后面的参数</p>
<p>sys.argv 返回值是一个列表</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.argv) <span class="comment"># [&#x27;home.py&#x27;, &#x27;123&#x27;, &#x27;456&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(sys.argv)) <span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本名</span></span><br><span class="line"><span class="built_in">print</span>(sys.argv[<span class="number">0</span>]) <span class="comment"># home.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个参数</span></span><br><span class="line"><span class="built_in">print</span>(sys.argv[<span class="number">1</span>])  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个参数</span></span><br><span class="line"><span class="built_in">print</span>(sys.argv[<span class="number">2</span>]) <span class="comment"># 456</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.2 <code>sys.path</code></p>
<blockquote>
<p>系统寻找模块的路径，可通过PYTHONPATH来初始化</p>
</blockquote>
<p>2.3 <code>sys.module</code></p>
<blockquote>
<p>系统加载的模块</p>
</blockquote>
<h3 id="3、logging模块"><a href="#3、logging模块" class="headerlink" title="3、logging模块"></a>3、logging模块</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Eva-j/articles/7228075.html#_label14">https://www.cnblogs.com/Eva-j/articles/7228075.html#_label14</a></p>
</blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志作用:</span></span><br><span class="line"><span class="comment">#   1.用来记录用户行为 - 数据分析</span></span><br><span class="line"><span class="comment">#   2.用来记录用户行为 - 操作审计</span></span><br><span class="line"><span class="comment">#   3.排查代码错误</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>3.1 logging简单配置</p>
<blockquote>
<ol>
<li>默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，默认的日志级别设置为WARNING</li>
<li>日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG</li>
<li>默认的日志格式为日志级别：Logger名称：用户输出消息，比如：<code>WARNING:root:warning msg</code></li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&quot;debug msg&quot;</span>) <span class="comment"># 调试</span></span><br><span class="line">logging.info(<span class="string">&quot;info msg&quot;</span>)  <span class="comment"># 信息</span></span><br><span class="line">logging.warning(<span class="string">&quot;warning msg&quot;</span>) <span class="comment"># 警告</span></span><br><span class="line">logging.error(<span class="string">&quot;error msg&quot;</span>) <span class="comment"># 错误</span></span><br><span class="line">logging.critical(<span class="string">&quot;critical msg&quot;</span>) <span class="comment"># 批判性的</span></span><br></pre></td></tr></table></figure>

<p>3.2 logging自定义配置等级、格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    <span class="comment"># 标准业务log格式: WARNING: 2020-05-22 17:56:37 [D:/Flask/MyOffice/tests_code/loggerstudy/logstudy01.py:31] a=33</span></span><br><span class="line">    <span class="built_in">format</span>= <span class="string">&#x27;%(levelname)s: %(asctime)s [%(pathname)s:%(lineno)d] %(message)s&#x27;</span>,</span><br><span class="line">    datefmt= <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    a = <span class="number">33</span></span><br><span class="line">    logging.warning(<span class="string">f&quot;a=<span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>3.3 输出日志到文件和屏幕</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件操作符，写入日志到文件，</span></span><br><span class="line"><span class="comment"># 这里需要注意写了几个fileHandler，就会输出到几个文件中</span></span><br><span class="line">fh1 = logging.FileHandler(<span class="string">&quot;tmp1.log&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">fh2 = logging.FileHandler(<span class="string">&quot;tmp2.log&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 流处理输出到屏幕</span></span><br><span class="line">sh = logging.StreamHandler()</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    <span class="comment"># 标准业务log格式: WARNING: 2020-05-22 17:56:37 [D:/Flask/MyOffice/tests_code/loggerstudy/logstudy01.py:31] a=33</span></span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(levelname)s: %(asctime)s [%(pathname)s:%(lineno)d] %(message)s&#x27;</span>,</span><br><span class="line">    datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置logging等级</span></span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填写上面的handler</span></span><br><span class="line">    handlers=[fh1,fh2,sh],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    a = <span class="number">89</span></span><br><span class="line">    logging.debug(<span class="built_in">str</span>(a))</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.4 日志切分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging,time</span><br><span class="line"><span class="keyword">from</span> logging <span class="keyword">import</span> handlers</span><br><span class="line"></span><br><span class="line">sh = logging.StreamHandler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照文件大小进行切割，最多保留5个文件，超过5个会删掉第一个，重新生成一个新的，可以通过日期生成时间观察第一个是否被删掉</span></span><br><span class="line"><span class="comment"># 总是保持生成五个日志文件</span></span><br><span class="line">rh = handlers.RotatingFileHandler(<span class="string">&#x27;myapp.log&#x27;</span>, maxBytes=<span class="number">1024</span>,backupCount=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按时间切割，when=&quot;s&quot;,表示按秒切，interval=5表示5s切一个，持续切割</span></span><br><span class="line">fh = handlers.TimedRotatingFileHandler(filename=<span class="string">&#x27;x2.log&#x27;</span>, when=<span class="string">&#x27;s&#x27;</span>, interval=<span class="number">5</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    <span class="comment"># 标准业务log格式: WARNING: 2020-05-22 17:56:37 [D:/Flask/MyOffice/tests_code/loggerstudy/logstudy01.py:31] a=33</span></span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(levelname)s: %(asctime)s [%(pathname)s:%(lineno)d] %(message)s&#x27;</span>,</span><br><span class="line">    datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置logging等级</span></span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填写上面的handler</span></span><br><span class="line">    handlers=[rh,fh,sh],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100000</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    logging.error(<span class="string">&#x27;KeyboardInterrupt error %s&#x27;</span>%<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>

<h3 id="4、内置函数"><a href="#4、内置函数" class="headerlink" title="4、内置函数"></a>4、内置函数</h3><p>4.1  abs</p>
<blockquote>
<p>返回负数的绝对值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>4.2 all</p>
<blockquote>
<p>所有值都为true，才是true</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>( <span class="built_in">all</span>([]) )  <span class="comment">#true</span></span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">all</span>([<span class="number">1</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;1&quot;</span>]) ) <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p>4.3 any</p>
<blockquote>
<p>只要循环出来的值有一个为真，那结果就是true</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>( <span class="built_in">any</span>([<span class="number">1</span>,<span class="literal">None</span>,<span class="string">&quot;1&quot;</span>]) ) <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p>4.4 callable</p>
<blockquote>
<p>表示传入的值是否可以被调用，可以调用返回true，否则为false</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">callable</span>(func) )</span><br></pre></td></tr></table></figure>

<p>4.5 dir</p>
<blockquote>
<p>查看对象有哪些属性</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>( <span class="built_in">dir</span>(<span class="built_in">list</span>) )</span><br></pre></td></tr></table></figure>

<p>4.6 <code>divmod</code></p>
<blockquote>
<ul>
<li>接收两个参数，第一个是除数，第二个是被除数</li>
<li>结果是元组，第一个值是商，第二个是余数</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">divmod</span>(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br></pre></td></tr></table></figure>

<p>4.7 enumerate</p>
<blockquote>
<p>返回序列的索引和值，索引在值的前面</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index,ele <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;index=<span class="subst">&#123;index&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;ele=<span class="subst">&#123;ele&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<p>4.8 eval</p>
<blockquote>
<p>执行字符串的表达式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">eval</span>(<span class="string">&#x27;&#123;&quot;a&quot;:1&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res,<span class="built_in">type</span>(res))</span><br></pre></td></tr></table></figure>

<p>4.9 isinstance</p>
<blockquote>
<ul>
<li>做类型判断，前一个参数是不是第二格参数的所指的类型</li>
<li>返回值是true或false</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(obj,Foo))</span><br></pre></td></tr></table></figure>

<h3 id="5、time模块"><a href="#5、time模块" class="headerlink" title="5、time模块"></a>5、time模块</h3><blockquote>
<p>时间模块，比较常用</p>
</blockquote>
<h4 id="1-1-time-time"><a href="#1-1-time-time" class="headerlink" title="1.1 time.time()"></a>1.1 <code>time.time()</code></h4><blockquote>
<p>用于获取当前时间戳，从1970年到现在的秒数，如果要取的时间戳是毫秒级别，需要乘以1000</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、时间戳: 从1970年到现在的秒数</span></span><br><span class="line">t1 = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t1=&quot;</span>, t1) <span class="comment"># 2021-12-22 22:37:10</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-time-localtime"><a href="#1-2-time-localtime" class="headerlink" title="1.2 time.localtime()"></a>1.2 <code>time.localtime()</code></h4><blockquote>
<p>用于获取结构化时间，常用来单独取时间的某一部分，比如年、月、日等</p>
</blockquote>
<blockquote>
<p>看<code>time.localtime()</code>的实现源码：</p>
<ul>
<li>其实就解释了它可以接收<code>时间戳</code>(秒数，不是毫秒数)，然后转化为结构化时间</li>
<li>当然它的默认值是None，不传秒数就是取<code>当前时间戳</code>转化为结构化时间</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">localtime</span>(<span class="params">seconds=<span class="literal">None</span></span>): <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    localtime([seconds]) -&gt; (tm_year,tm_mon,tm_mday,tm_hour,tm_min,</span></span><br><span class="line"><span class="string">                              tm_sec,tm_wday,tm_yday,tm_isdst)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Convert seconds since the Epoch to a time tuple expressing local time.</span></span><br><span class="line"><span class="string">    When &#x27;seconds&#x27; is not passed in, convert the current time instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>转化的例子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构花时间</span></span><br><span class="line"><span class="comment"># 用于单独获取时间的某一部分</span></span><br><span class="line"><span class="comment"># t4: time.struct_time(tm_year=2021, tm_mon=12, tm_mday=22, tm_hour=22, tm_min=38, tm_sec=55, tm_wday=2, tm_yday=356, tm_isdst=0)</span></span><br><span class="line">t4 = time.localtime()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t4=&quot;</span>, t4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t4 year=&quot;</span>, t4.tm_year) <span class="comment"># 2021</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t4 mon=&quot;</span>, t4.tm_mon) <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t4 mday=&quot;</span>, t4.tm_mday) <span class="comment"># 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入一个时间戳，1640183901</span></span><br><span class="line"><span class="comment"># t5: time.struct_time(tm_year=2021, tm_mon=12, tm_mday=20, tm_hour=22, tm_min=21, tm_sec=41, tm_wday=0, tm_yday=354, tm_isdst=0)</span></span><br><span class="line">t5 = time.localtime(<span class="number">1640010101</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t5==&gt;&quot;</span>, t5)</span><br></pre></td></tr></table></figure>

<h4 id="1-3-time-strftime"><a href="#1-3-time-strftime" class="headerlink" title="1.3 time.strftime()"></a>1.3 <code>time.strftime()</code></h4><blockquote>
<p>字符串格式显示的时间，常用对外展示比较可阅读的时间，比如：<code>2021-12-20 22:21:41</code></p>
</blockquote>
<blockquote>
<p>查看源码可以看出：</p>
<ul>
<li>主要用来将一个时间元祖(也就是结构化时间)，根据一定的格式进行转化</li>
<li>当时间元祖没有传入时，取当前时间的<code>time.localtime()</code>作为替代</li>
<li>所以可以使用将结构化时间传入给该函数</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">strftime</span>(<span class="params"><span class="built_in">format</span>, p_tuple=<span class="literal">None</span></span>): <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    strftime(format[, tuple]) -&gt; string</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Convert a time tuple to a string according to a format specification.</span></span><br><span class="line"><span class="string">    See the library reference manual for formatting codes. When the time tuple</span></span><br><span class="line"><span class="string">    is not present, current time as returned by localtime() is used.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Commonly used format codes:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    %Y  Year with century as a decimal number.</span></span><br><span class="line"><span class="string">    %m  Month as a decimal number [01,12].</span></span><br><span class="line"><span class="string">    %d  Day of the month as a decimal number [01,31].</span></span><br><span class="line"><span class="string">    %H  Hour (24-hour clock) as a decimal number [00,23].</span></span><br><span class="line"><span class="string">    %M  Minute as a decimal number [00,59].</span></span><br><span class="line"><span class="string">    %S  Second as a decimal number [00,61].</span></span><br><span class="line"><span class="string">    %z  Time zone offset from UTC.</span></span><br><span class="line"><span class="string">    %a  Locale&#x27;s abbreviated weekday name.</span></span><br><span class="line"><span class="string">    %A  Locale&#x27;s full weekday name.</span></span><br><span class="line"><span class="string">    %b  Locale&#x27;s abbreviated month name.</span></span><br><span class="line"><span class="string">    %B  Locale&#x27;s full month name.</span></span><br><span class="line"><span class="string">    %c  Locale&#x27;s appropriate date and time representation.</span></span><br><span class="line"><span class="string">    %I  Hour (12-hour clock) as a decimal number [01,12].</span></span><br><span class="line"><span class="string">    %p  Locale&#x27;s equivalent of either AM or PM.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Other codes may be available on your platform.  See documentation for</span></span><br><span class="line"><span class="string">    the C library strftime function.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>转化的例子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t2 = time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>)</span><br><span class="line">t3 = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t2=&quot;</span>, t2)  <span class="comment"># 2021-12-22 22:37:10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t3=&quot;</span>, t3) <span class="comment"># 2021-12-22 22:37:10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要传入一个结构化时间，那么可以对时间戳先转化为结构化时间，在给strftime()传入</span></span><br><span class="line"><span class="comment"># t5是一个结构化时间，指定一个时间戳戳: 1640010101</span></span><br><span class="line"><span class="comment"># t5: time.struct_time(tm_year=2021, tm_mon=12, tm_mday=20, tm_hour=22, tm_min=21, tm_sec=41, tm_wday=0, tm_yday=354, tm_isdst=0)</span></span><br><span class="line">t5 = time.localtime(<span class="number">1640010101</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t5==&gt;&quot;</span>, t5)</span><br><span class="line">t6 = time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>, t5)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t6==&gt;&quot;</span>, t6) <span class="comment"># 2021-12-20 22:21:41</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-time-strptime"><a href="#1-4-time-strptime" class="headerlink" title="1.4 time.strptime()"></a>1.4 <code>time.strptime()</code></h4><blockquote>
<p>主要用来将字符串时间转换为格式化时间</p>
</blockquote>
<blockquote>
<p>来看源码:</p>
<ul>
<li>看源码注释解释：根据传入的时间格式，将一个字符串时间转化成一个结构化时间</li>
<li>而且它的返回值就是一个<code>结构化时间</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">strptime</span>(<span class="params">string, <span class="built_in">format</span></span>): <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    strptime(string, format) -&gt; struct_time</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parse a string to a time tuple according to a format specification.</span></span><br><span class="line"><span class="string">    See the library reference manual for formatting codes (same as</span></span><br><span class="line"><span class="string">    strftime()).</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Commonly used format codes:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    %Y  Year with century as a decimal number.</span></span><br><span class="line"><span class="string">    %m  Month as a decimal number [01,12].</span></span><br><span class="line"><span class="string">    %d  Day of the month as a decimal number [01,31].</span></span><br><span class="line"><span class="string">    %H  Hour (24-hour clock) as a decimal number [00,23].</span></span><br><span class="line"><span class="string">    %M  Minute as a decimal number [00,59].</span></span><br><span class="line"><span class="string">    %S  Second as a decimal number [00,61].</span></span><br><span class="line"><span class="string">    %z  Time zone offset from UTC.</span></span><br><span class="line"><span class="string">    %a  Locale&#x27;s abbreviated weekday name.</span></span><br><span class="line"><span class="string">    %A  Locale&#x27;s full weekday name.</span></span><br><span class="line"><span class="string">    %b  Locale&#x27;s abbreviated month name.</span></span><br><span class="line"><span class="string">    %B  Locale&#x27;s full month name.</span></span><br><span class="line"><span class="string">    %c  Locale&#x27;s appropriate date and time representation.</span></span><br><span class="line"><span class="string">    %I  Hour (12-hour clock) as a decimal number [01,12].</span></span><br><span class="line"><span class="string">    %p  Locale&#x27;s equivalent of either AM or PM.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Other codes may be available on your platform.  See documentation for</span></span><br><span class="line"><span class="string">    the C library strftime function.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> struct_time</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个字符串时间转化为结构化时间</span></span><br><span class="line"><span class="comment"># t1 = time.struct_time(tm_year=2021, tm_mon=11, tm_mday=22, tm_hour=23, tm_min=27, tm_sec=55, tm_wday=0, tm_yday=326, tm_isdst=-1)</span></span><br><span class="line">t_str = <span class="string">&quot;2021-11-22 23:27:55&quot;</span></span><br><span class="line">t1 = time.strptime(t_str, <span class="string">&quot;%Y-%m-%d %X&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t1===&gt;&quot;</span>, t1)</span><br></pre></td></tr></table></figure>

<h4 id="1-5-time-mktime"><a href="#1-5-time-mktime" class="headerlink" title="1.5 time.mktime()"></a>1.5 <code>time.mktime()</code></h4><blockquote>
<p>主要是用来将结构化时间转换为时间戳</p>
</blockquote>
<blockquote>
<p>来看源码：</p>
<ul>
<li>源码注释说：将一个本地的<code>结构化时间</code>转化成<code>秒数</code></li>
<li>返回的是一个浮点数，需要返回整数时，就需要<code>int()</code>进行转换</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mktime</span>(<span class="params">p_tuple</span>): <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mktime(tuple) -&gt; floating point number</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Convert a time tuple in local time to seconds since the Epoch.</span></span><br><span class="line"><span class="string">    Note that mktime(gmtime(0)) will not generally return zero for most</span></span><br><span class="line"><span class="string">    time zones; instead the returned value will either be equal to that</span></span><br><span class="line"><span class="string">    of the timezone or altzone attributes on the time module.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># t7是结构化时间</span></span><br><span class="line"><span class="comment"># t7: time.struct_time(tm_year=2021, tm_mon=12, tm_mday=22, tm_hour=23, tm_min=28, tm_sec=28, tm_wday=2, tm_yday=356, tm_isdst=0)</span></span><br><span class="line">t7 = time.localtime()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t7===&gt;&quot;</span>, t7)</span><br><span class="line">t8 = <span class="built_in">int</span>(time.mktime(t7)) * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t8===&gt;&quot;</span>, t8) <span class="comment"># 1640186908000</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5-时间戳转换为字符串时间"><a href="#1-5-时间戳转换为字符串时间" class="headerlink" title="1.5 时间戳转换为字符串时间"></a>1.5 时间戳转换为字符串时间</h4><blockquote>
<p>下图是转化的图</p>
</blockquote>
<img src="/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/image-20211222232146570.png" class="" title="image-20211222232146570">

<blockquote>
<p>转化的代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将t1时间戳转化为字符串时间</span></span><br><span class="line">t1 = <span class="number">1637594296</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t1时间戳:&quot;</span>, t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化为结构化时间</span></span><br><span class="line">t1 = time.localtime(t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化为字符串时间</span></span><br><span class="line">t1 = time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>, t1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t1字符串时间:&quot;</span>, t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># t1时间戳: 1637594296</span></span><br><span class="line"><span class="comment"># t1字符串时间: 2021-11-22 23:18:16</span></span><br></pre></td></tr></table></figure>

<h4 id="1-6-字符串时间转化为时间戳"><a href="#1-6-字符串时间转化为时间戳" class="headerlink" title="1.6 字符串时间转化为时间戳"></a>1.6 字符串时间转化为时间戳</h4><blockquote>
<p>下图是转化的图</p>
</blockquote>
<img src="/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/image-20211222234739800.png" class="" title="image-20211222234739800">

<blockquote>
<p>下面是转化的代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将t1字符串时间转化为时间戳</span></span><br><span class="line">t1 = <span class="string">&quot;2021-11-22 23:27:55&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t1字符串:&quot;</span>, t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先转化为结构化时间</span></span><br><span class="line">t1 = time.strptime(t1, <span class="string">&quot;%Y-%m-%d %X&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再将结构化时间转化为时间戳</span></span><br><span class="line">t1 = <span class="built_in">int</span>(time.mktime(t1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t1时间戳:&quot;</span>, t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果:</span></span><br><span class="line"><span class="comment"># t1字符串: 2021-11-22 23:27:55</span></span><br><span class="line"><span class="comment"># t1时间戳: 1637594875</span></span><br></pre></td></tr></table></figure>

<h3 id="6、datetime模块"><a href="#6、datetime模块" class="headerlink" title="6、datetime模块"></a>6、datetime模块</h3><blockquote>
<p><code>datetime</code>也是一个时间模块，不同于<code>time</code>模块，可以用来对时间进行加减</p>
</blockquote>
<h4 id="1-1-当前时间"><a href="#1-1-当前时间" class="headerlink" title="1.1 当前时间"></a>1.1 当前时间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前时间</span></span><br><span class="line">now_time = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># now_time: 2021-12-22 23:55:17.339830</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;now_time:&quot;</span>, now_time)</span><br><span class="line"></span><br><span class="line"><span class="comment"># now_time type: &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;now_time type:&quot;</span>, <span class="built_in">type</span>(now_time))</span><br></pre></td></tr></table></figure>

<h4 id="1-2-时间加减"><a href="#1-2-时间加减" class="headerlink" title="1.2 时间加减"></a>1.2 时间加减</h4><blockquote>
<p><code>datetime</code>可以对时间进行加减，使用<code>datetime.timedelta()</code></p>
</blockquote>
<blockquote>
<p>先看源码</p>
<ul>
<li>可以看到这个时间加减类，接收<code>days</code>&#x2F;<code>seconds</code>&#x2F;<code>weeks</code>&#x2F;<code>hours</code>等格式，传入的值是一个float类型</li>
<li><code>float = ...</code> 这三个点在python中表示是<code>&lt;class ellipsis&gt;</code>，用来占位的，和pass一样</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">timedelta</span>(SupportsAbs[timedelta]):</span><br><span class="line">    <span class="built_in">min</span>: ClassVar[timedelta]</span><br><span class="line">    <span class="built_in">max</span>: ClassVar[timedelta]</span><br><span class="line">    resolution: ClassVar[timedelta]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        days: <span class="built_in">float</span> = ...,</span></span><br><span class="line"><span class="params">        seconds: <span class="built_in">float</span> = ...,</span></span><br><span class="line"><span class="params">        microseconds: <span class="built_in">float</span> = ...,</span></span><br><span class="line"><span class="params">        milliseconds: <span class="built_in">float</span> = ...,</span></span><br><span class="line"><span class="params">        minutes: <span class="built_in">float</span> = ...,</span></span><br><span class="line"><span class="params">        hours: <span class="built_in">float</span> = ...,</span></span><br><span class="line"><span class="params">        weeks: <span class="built_in">float</span> = ...,</span></span><br><span class="line"><span class="params">        *,</span></span><br><span class="line"><span class="params">        fold: <span class="built_in">int</span> = ...,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">days</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>: ...</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">seconds</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>: ...</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">microseconds</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>: ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">total_seconds</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>: ...</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前时间</span></span><br><span class="line">now_time = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># now_time: 2021-12-22 23:55:17.339830</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;now_time:&quot;</span>, now_time) <span class="comment"># 2021-12-23 00:09:04.046012</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># now_time type: &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;now_time type:&quot;</span>, <span class="built_in">type</span>(now_time)) <span class="comment"># &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 天数加减</span></span><br><span class="line">three_day_later = now_time + datetime.timedelta(days=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;三天后:&quot;</span>, three_day_later) <span class="comment"># 2021-12-26 00:09:04.046012</span></span><br><span class="line"></span><br><span class="line">three_day_early = now_time + datetime.timedelta(days=-<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;三天前:&quot;</span>, three_day_early) <span class="comment"># 2021-12-20 00:09:04.046012</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-时间戳转化为datetime类型的字符串时间"><a href="#1-3-时间戳转化为datetime类型的字符串时间" class="headerlink" title="1.3 时间戳转化为datetime类型的字符串时间"></a>1.3 时间戳转化为datetime类型的字符串时间</h4><blockquote>
<p>一步到位将时间戳转化为字符串格式的时间，此时的字符串格式时间类型是<code>&lt;class &#39;datetime.datetime&#39;&gt;</code>，可以使用<code>datetime.timedelta()</code>进行时间的加减</p>
<ul>
<li>其实<code>time</code>模块也可以做到，但是需要两步<ul>
<li>第一步需要先转化为结构化时间</li>
<li>第二步需要指定输出字符串的格式</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束时间+7天</span></span><br><span class="line"><span class="comment"># 对时间戳进行加减N天</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前时间戳</span></span><br><span class="line">t1 = time.time()</span><br><span class="line">t2 = datetime.datetime.fromtimestamp(t1) + datetime.timedelta(days=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2021-12-30 00:47:04.755311</span></span><br><span class="line"><span class="built_in">print</span>(t2) </span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再将加了N天的时间转化为时间戳</span></span><br><span class="line">t3 = t2.timetuple()</span><br><span class="line">t3_stamp = <span class="built_in">int</span>(time.mktime(t3)) * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(t3_stamp) <span class="comment"># 1640796424000</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-datetime类型的字符串时间转化为时间戳"><a href="#1-4-datetime类型的字符串时间转化为时间戳" class="headerlink" title="1.4 datetime类型的字符串时间转化为时间戳"></a>1.4 datetime类型的字符串时间转化为时间戳</h4><blockquote>
<p>将类型是<code>&lt;class &#39;datetime.datetime&#39;&gt;</code>的字符串时间转换为时间戳，比如我对某个时间进行了加减，然后需要转换为时间戳存起来</p>
<p>注意:</p>
<ul>
<li><code>datetime.datetime.now()</code>返回的时间类型是<code>&lt;class &#39;datetime.datetime&#39;&gt;</code></li>
<li>可以通过<code>timetuple()</code>将时间类型为<code>&lt;class &#39;datetime.datetime&#39;&gt;</code>转换为结构化时间</li>
<li>最后再使用<code>time.mktime()</code>转化为时间戳</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">three_day_early = datetime.datetime.now() + datetime.timedelta(days=-<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;三天前:&quot;</span>, three_day_early) <span class="comment"># 2021-12-20 00:33:05.384049</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;三天前格式:&quot;</span>, <span class="built_in">type</span>(three_day_early)) <span class="comment"># &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># timetuple() 返回的是结构化时间</span></span><br><span class="line">struct_three_day_early = three_day_early.timetuple()</span><br><span class="line"></span><br><span class="line">t1 = <span class="built_in">int</span>(time.mktime(struct_three_day_early)) * <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(t1) <span class="comment"># 1639931585000</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5-datetime和time模块复习"><a href="#1-5-datetime和time模块复习" class="headerlink" title="1.5 datetime和time模块复习"></a>1.5 datetime和time模块复习</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime, time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_switch_to_stamp</span>():</span><br><span class="line">    <span class="comment"># 时间戳转换为字符串时间戳</span></span><br><span class="line">    s = <span class="number">1640796424000</span> // <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转为结构体</span></span><br><span class="line">    s_struct = time.localtime(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转为字符串时间</span></span><br><span class="line">    s_str_time = time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(s_str_time)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 字符串格式转化为时间戳</span></span><br><span class="line">    s_str_time_new = <span class="string">&quot;2021-12-25 10:00:00&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先转化为结构化时间</span></span><br><span class="line">    s_struct_new = time.strptime(s_str_time_new, <span class="string">&quot;%Y-%m-%d %X&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再转化为时间戳</span></span><br><span class="line">    s_time_new_stamp = <span class="built_in">int</span>(time.mktime(s_struct_new))</span><br><span class="line">    <span class="built_in">print</span>(s_time_new_stamp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datetime_switch_to_stamp</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这个里面既包含了将时间戳转换为字符串时间，也包含了将字符串时间转换为时间戳</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 在存在的一个时间戳上+N天，并且再将最后的N天转换为时间戳</span></span><br><span class="line">    s = <span class="number">1640796424000</span> // <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    three_day_later = datetime.datetime.fromtimestamp(s) + datetime.timedelta(days=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 三天后的时间转化为时间戳</span></span><br><span class="line">    <span class="comment"># step1: 三天后的时间转化为结构化时间</span></span><br><span class="line">    new_struct_time = three_day_later.timetuple()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2: 再将结构化时间转换为是时间戳</span></span><br><span class="line">    new_time_stamp = <span class="built_in">int</span>(time.mktime(new_struct_time))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(new_time_stamp)</span><br></pre></td></tr></table></figure>

<h2 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h2><h3 id="1、正则表达式"><a href="#1、正则表达式" class="headerlink" title="1、正则表达式"></a>1、正则表达式</h3><blockquote>
<p>定义：一套规则，匹配字符串</p>
<p>功能：检测一个输入的字符串是否合法，从一个大文件中找到所有符合规则的内容</p>
<p>推荐一个正则好用的网站:</p>
<p><a target="_blank" rel="noopener" href="http://tool.chinaz.com/regex/">http://tool.chinaz.com/regex/</a></p>
</blockquote>
<h3 id="2、元字符"><a href="#2、元字符" class="headerlink" title="2、元字符"></a>2、元字符</h3><blockquote>
</blockquote>
<h3 id="x、正则小例子"><a href="#x、正则小例子" class="headerlink" title="x、正则小例子"></a>x、正则小例子</h3><h4 id="x-1-切割cookies为字典"><a href="#x-1-切割cookies为字典" class="headerlink" title="x.1 切割cookies为字典"></a>x.1 切割cookies为字典</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_cookie</span>():</span><br><span class="line">    cookie_list1 = cookie_str.split(<span class="string">&quot;;&quot;</span>)</span><br><span class="line">    ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> cookie_list1:</span><br><span class="line">        d = re.split(<span class="string">r&quot;=&quot;</span>, i.strip(), maxsplit=<span class="number">1</span>)</span><br><span class="line">        ret[d[<span class="number">0</span>]] = d[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>



<h2 id="七、进程和线程"><a href="#七、进程和线程" class="headerlink" title="七、进程和线程"></a>七、进程和线程</h2><h3 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h3><blockquote>
<p>进行中的程序就是一个进程</p>
<p>1.占用资源</p>
<p>2.pid: 能唯一标识一个进程</p>
<p>3.计算机中最小的资源分配单位</p>
</blockquote>
<h3 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h3><h4 id="1-1-并发"><a href="#1-1-并发" class="headerlink" title="1.1 并发"></a>1.1 并发</h4><blockquote>
<ul>
<li>多个程序轮流在一个单核cpu上执行</li>
<li>宏观上：多个程序在同时执行</li>
<li>微观上：多个程序轮流在一个cpu上执行，本质还是串行</li>
<li>本质：每个任务都是交替执行，但由于CPU执行速度太快，所以我们感觉是所有任务都在同时执行</li>
</ul>
</blockquote>
<h4 id="1-2-并行"><a href="#1-2-并行" class="headerlink" title="1.2 并行"></a>1.2 并行</h4><blockquote>
<ul>
<li>多个程序同时执行，并且同时在多核cpu上执行</li>
<li>真正的并行执行多任务也只能在多核cpu上实现，但是由于任务数量远远多于cpu核心数量，所以操作系统也会自动把很多任务轮流调度到每个核上去执行</li>
</ul>
</blockquote>
<h3 id="3、同步、异步、阻塞、非阻塞"><a href="#3、同步、异步、阻塞、非阻塞" class="headerlink" title="3、同步、异步、阻塞、非阻塞"></a>3、同步、异步、阻塞、非阻塞</h3><h4 id="1-1-同步"><a href="#1-1-同步" class="headerlink" title="1.1 同步"></a>1.1 同步</h4><blockquote>
<p>在做A事的时候发起B事件，必须等待B事件完成后才能继续做A事</p>
</blockquote>
<h4 id="1-2-异步"><a href="#1-2-异步" class="headerlink" title="1.2 异步"></a>1.2 异步</h4><blockquote>
<p>在做A事的时候发起B事件，不需要等待B事件完成后才能继续做A事</p>
</blockquote>
<h4 id="1-3-阻塞"><a href="#1-3-阻塞" class="headerlink" title="1.3 阻塞"></a>1.3 阻塞</h4><blockquote>
<p>如果CPU不工作了，input accept  recv  recvfrom sleep connect</p>
</blockquote>
<h4 id="1-4-非阻塞"><a href="#1-4-非阻塞" class="headerlink" title="1.4 非阻塞"></a>1.4 非阻塞</h4><blockquote>
<p>CPU正常在工作</p>
</blockquote>
<h3 id="4、线程"><a href="#4、线程" class="headerlink" title="4、线程"></a>4、线程</h3><blockquote>
<p>线程是进程中的一个单位，不能脱离进程存在</p>
<p>线程是计算机中能被CPU调度的最小单位</p>
<p>python的thread模块比较底层，python的threading模块对thread做了一些包装，方便使用</p>
</blockquote>
<h3 id="5、threading多线程"><a href="#5、threading多线程" class="headerlink" title="5、threading多线程"></a>5、threading多线程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> sing start time:<span class="subst">&#123;time.strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> sing end time:<span class="subst">&#123;time.strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> walk start time:<span class="subst">&#123;time.strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> walk end time:<span class="subst">&#123;time.strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sing_th = threading.Thread(target=sing, args=(<span class="string">&quot;bob&quot;</span>,))</span><br><span class="line">walk_th = threading.Thread(target=walk, args=(<span class="string">&quot;sam&quot;</span>,))</span><br><span class="line"></span><br><span class="line">ths = [sing_th, walk_th]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> th <span class="keyword">in</span> ths:</span><br><span class="line">    th.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> th <span class="keyword">in</span> ths:</span><br><span class="line">    th.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;done!!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6、线程池"><a href="#6、线程池" class="headerlink" title="6、线程池"></a>6、线程池</h3><blockquote>
<p>线程池比较适合做多个目标做同一件事</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> sing start time:<span class="subst">&#123;time.strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> sing end time:<span class="subst">&#123;time.strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启线程池，最多1次有10个线程被执行</span></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">users = [<span class="string">&quot;sam&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;tom&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发执行</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> users:</span><br><span class="line">    pool.submit(sing, name=name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待子线程执行完成</span></span><br><span class="line">pool.shutdown(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;done!&quot;</span>)</span><br></pre></td></tr></table></figure>

<img src="/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/image-20230217135229336.png" class="" title="image-20230217135229336">

<h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1、类定义"><a href="#1、类定义" class="headerlink" title="1、类定义"></a>1、类定义</h3><h4 id="1-1-类的实例化"><a href="#1-1-类的实例化" class="headerlink" title="1.1 类的实例化"></a>1.1 类的实例化</h4><blockquote>
<ul>
<li>实例化：<ul>
<li>调用类的过程称为实例化</li>
</ul>
</li>
<li>实例化发生了三件事<ul>
<li>1.先产生了一个空对象</li>
<li>2.<code>python</code>会自动调用类的<code>__init__</code>方法将空对象已经调用类时括号内传入的参数一同传给<code>__init__</code>方法</li>
<li>3.返回初始化完成的对象</li>
</ul>
</li>
<li><code>__init__</code>总结<ul>
<li>1.会在调用类时自动触发执行，用来为对象初始化自己的独有的数据</li>
<li>2.因为<code>__init__</code>是自动触发执行的，而且<code>__init__</code>里存放的是为对象初始化属性的功能，就可以存放任何其他代码，想要在类调用时就立刻执行的代码都可以放到该方法中</li>
<li>3.<code>__init__</code>方法必须返回None</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 变量定义</span></span><br><span class="line">    tag = <span class="string">&quot;Tim&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name_v,age_v</span>):  <span class="comment"># self 就是obj_a这个空对象</span></span><br><span class="line">        self.name_k = name_v   <span class="comment"># obj_a.name = name -&gt; obj_a这个对象字典中&#123;name_k:name_v&#125;</span></span><br><span class="line">        self.age_k = age_v     <span class="comment"># obj_a.age_k = age_v -&gt; obj_a这个对象字典中&#123;name_k:name_v,age_k:age_v&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;the car cost:<span class="subst">&#123;self.name_k&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj_a = A(<span class="string">&quot;sam&quot;</span>,<span class="number">19</span>) <span class="comment"># A.__init__(空对象，&quot;sam&quot;,19)，然后将创建好的类返回给obj_a这个对象</span></span><br><span class="line"><span class="built_in">print</span>(obj_a.__dict__) <span class="comment">#&#123;&#x27;name_k&#x27;: &#x27;sam&#x27;, &#x27;age_k&#x27;: 19&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-类的属性查找"><a href="#1-2-类的属性查找" class="headerlink" title="1.2 类的属性查找"></a>1.2 类的属性查找</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    tag = <span class="string">&quot;Tim&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name_v,age_v</span>):</span><br><span class="line">        self.name_k = name_v</span><br><span class="line">        self.age_k = age_v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;the car cost:<span class="subst">&#123;self.name_k&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj_a = A(<span class="string">&quot;sam&quot;</span>,<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类中存放的是对象共有的数据与功能</span></span><br><span class="line"><span class="comment"># 类可以访问:</span></span><br><span class="line"><span class="comment"># 1.类的数据属性</span></span><br><span class="line"><span class="built_in">print</span>(A.tag) <span class="comment"># Tim,就是tag的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.类的函数属性</span></span><br><span class="line"><span class="built_in">print</span>(A.drive) <span class="comment"># &lt;function A.drive at 0x00000000028B9B70&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类的数据属性和函数属性就是为对象服务的，对象在调用时，会先从自己的属性字典中去找，如果没有找到就会去类的属性字典去找</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-对象使用类方法就是绑定方法"><a href="#1-3-对象使用类方法就是绑定方法" class="headerlink" title="1.3 对象使用类方法就是绑定方法"></a>1.3 对象使用类方法就是绑定方法</h4><blockquote>
<p>对象调用类中方法，调用哪个方法，就会和这个方法形成绑定关系，并且将自己当做第一个形参传入给方法，然后类方法对这个对象进行各种操作</p>
</blockquote>
<h3 id="2、类的三大属性"><a href="#2、类的三大属性" class="headerlink" title="2、类的三大属性"></a>2、类的三大属性</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peng104/p/9550305.html">https://www.cnblogs.com/peng104/p/9550305.html</a></p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</blockquote>
<h3 id="3、封装"><a href="#3、封装" class="headerlink" title="3、封装"></a>3、封装</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109310247">https://zhuanlan.zhihu.com/p/109310247</a></p>
</blockquote>
<blockquote>
<p>封装是面向对象三大特性最核心的一个特性</p>
<p>封装就是将数据属性和方法属性整合到容器中，容器就是类，对象</p>
</blockquote>
<h4 id="1-1-私有变量、私有方法"><a href="#1-1-私有变量、私有方法" class="headerlink" title="1.1 私有变量、私有方法"></a>1.1 私有变量、私有方法</h4><blockquote>
<p>在属性名前加<code>__</code>(两个下划线)前缀，就会实现对外隐藏属性效果</p>
<p>Python的Class机制采用双下划线开头的方式将属性隐藏起来（设置成私有的），但其实这仅仅只是一种变形操作，类中所有双下滑线开头的属性都会在类定义阶段、检测语法时自动变成“_类名__属性名”的形式</p>
<p>在类外部无法直接访问双下滑线开头的属性，但知道了类名和属性名就可以拼出名字：<code>_类名__属性</code>，然后就可以访问了，如<code>Foo._A__N</code>，所以说这种操作并没有严格意义上地限制外部访问，仅仅只是一种语法意义上的变形。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    __N=<span class="number">0</span> <span class="comment"># 变形为_Foo__N</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="comment"># 定义函数时，会检测函数语法，所以__开头的属性也会变形</span></span><br><span class="line">        self.__x=<span class="number">10</span> <span class="comment"># 变形为self._Foo__x</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__f1</span>(<span class="params">self</span>): <span class="comment"># 变形为_Foo__f1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__f1 run&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">self</span>):  <span class="comment"># 定义函数时，会检测函数语法，所以__开头的属性也会变形</span></span><br><span class="line">        self.__f1() <span class="comment">#变形为self._Foo__f1()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo.__N) <span class="comment"># 报错AttributeError:类Foo没有属性__N</span></span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="built_in">print</span>(obbj.__x) <span class="comment"># 报错AttributeError:对象obj没有属性__x</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-property"><a href="#1-2-property" class="headerlink" title="1.2 property"></a>1.2 property</h4><blockquote>
<p>property:</p>
<ul>
<li>为此Python专门提供了一个装饰器property，可以将类中的函数“伪装成”对象的数据属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,weight,height</span>):</span><br><span class="line"><span class="meta">... </span>        self.name=name</span><br><span class="line"><span class="meta">... </span>        self.weight=weight</span><br><span class="line"><span class="meta">... </span>        self.height=height</span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">property</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">bmi</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.weight / (self.height**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj=People(<span class="string">&#x27;lili&#x27;</span>,<span class="number">75</span>,<span class="number">1.85</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.bmi <span class="comment">#触发方法bmi的执行，将obj自动传给self，执行后返回值作为本次引用的结果</span></span><br><span class="line"><span class="number">21.913805697589478</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用property有效地保证了属性访问的一致性。另外property还提供设置和删除属性的功能</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 变量定义</span></span><br><span class="line">    tag = <span class="string">&quot;Tim&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):  <span class="comment"># self 就是obj_a这个空对象</span></span><br><span class="line">        self.__name = name  <span class="comment"># obj_a.name = name -&gt; obj_a这个对象字典中&#123;name_k:name_v&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):   <span class="comment"># obj.name</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self,new_value</span>): <span class="comment"># obj.name = &quot;hall&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(new_value) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">str</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;new_value&#125;</span> must be string&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.__name = new_value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):  <span class="comment"># del obj.name</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.__name&#125;</span> cant not be delete&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = A(<span class="string">&quot;hawold&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;hall&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a.name</span><br></pre></td></tr></table></figure>

<h3 id="4、继承"><a href="#4、继承" class="headerlink" title="4、继承"></a>4、继承</h3><blockquote>
<p>继承：</p>
<ul>
<li>是一种创建新类的方式，新建的类可以被称为子类或派生类，父类被称为基类或超类</li>
<li>python支持多继承</li>
<li>用来解决类与类之间代码冗余问题</li>
</ul>
</blockquote>
<h4 id="1-1-继承的骨架"><a href="#1-1-继承的骨架" class="headerlink" title="1.1 继承的骨架"></a>1.1 继承的骨架</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub1</span>(<span class="title class_ inherited__">Parent1</span>):  <span class="comment"># 单继承</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub2</span>(Parent1,Parent2): <span class="comment"># 多继承</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看继承的父类</span></span><br><span class="line"><span class="built_in">print</span>(Sub1.__bases__) <span class="comment"># (&lt;class &#x27;__main__.Parent1&#x27;&gt;,)</span></span><br><span class="line"><span class="built_in">print</span>(Sub2.__bases__) <span class="comment"># (&lt;class &#x27;__main__.Parent1&#x27;&gt;, &lt;class &#x27;__main__.Parent2&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>Python2中有经典类和新式类区分</p>
<ul>
<li>经典类：没有继承object类的子类，以及该子类的子类子类</li>
<li>新式类：继承了object类的子类，以及该子类的子类子类</li>
</ul>
</li>
<li><p>Python3中没有新式类和经典类区分，默认继承object类，所以Python3就是新式类</p>
</li>
</ul>
</blockquote>
<h4 id="1-2-继承的属性查找"><a href="#1-2-继承的属性查找" class="headerlink" title="1.2 继承的属性查找"></a>1.2 继承的属性查找</h4><blockquote>
<ul>
<li>可以将多个子类中重复的部分抽离出来，形成一个父类让子类去继承</li>
<li>当子类的init方法初始化时参数比父类多，可以使用:<code>父类名.__init__(self,name,age,sex)</code>这种形式</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPeople</span>:</span><br><span class="line">    school = <span class="string">&#x27;harry&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,sex</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">MyPeople</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">choose_course</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 正在选课&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">MyPeople</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,sex,salary,level</span>):</span><br><span class="line">        <span class="comment"># 指名道姓去调用父类的__init__方法</span></span><br><span class="line">        MyPeople.__init__(self,name,age,sex)</span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>老师正在给学生上课&quot;</span>)</span><br><span class="line"></span><br><span class="line">stu_obj = Student(<span class="string">&quot;lili&quot;</span>,<span class="number">18</span>,<span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu_obj.choose_course()</span><br><span class="line"></span><br><span class="line">teacher_obj = Teacher(<span class="string">&quot;sam&quot;</span>,<span class="number">29</span>,<span class="string">&quot;female&quot;</span>,<span class="number">4000</span>,<span class="number">5</span>)</span><br><span class="line">teacher_obj.score()</span><br></pre></td></tr></table></figure>

<h4 id="1-3-单继承的属性查找"><a href="#1-3-单继承的属性查找" class="headerlink" title="1.3 单继承的属性查找"></a>1.3 单继承的属性查找</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单继承的属性查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Foo.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Foo.f2&quot;</span>)</span><br><span class="line">        self.f1() <span class="comment"># b.f1(),所以会先去b这个对象自己属性字典中找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bar.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b = Bar()</span></span><br><span class="line"><span class="comment"># b.f2()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要访问Foo的f1方法</span></span><br><span class="line"><span class="comment"># 方法一: Foo.f1(self)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Foo.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Foo.f2&quot;</span>)</span><br><span class="line">        Foo.f1(self) <span class="comment"># Foo.f1(self) 访问Foo类中f1方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bar.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二: 隐藏属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__f1</span>(<span class="params">self</span>): <span class="comment"># 变形: _Foo__f1()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Foo.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Foo.f2&quot;</span>)</span><br><span class="line">        self.__f1() <span class="comment"># self._Foo__f1(),因为b3这个子类的属性字典没有_Foo__f1这个属性，就会去父类中找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__f1</span>(<span class="params">self</span>): <span class="comment"># self._Bar__f1()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Bar.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line">b3 = Bar()</span><br><span class="line">b3.f2()</span><br></pre></td></tr></table></figure>

<h4 id="1-4-继承原理"><a href="#1-4-继承原理" class="headerlink" title="1.4 继承原理"></a>1.4 继承原理</h4><blockquote>
<ul>
<li><p>python到底是如何实现继承的呢？ 对于你定义的每一个类，Python都会计算出一个方法解析顺序(MRO)列表，该MRO列表就是一个简单的所有基类的线性顺序列表</p>
</li>
<li><p>python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>子类会先于父类被检查</span><br><span class="line"><span class="number">2.</span>多个父类会根据它们在列表中的顺序被检查</span><br><span class="line"><span class="number">3.</span>如果对下一个类存在两个合法的选择,选择第一个父类</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="1-5-多继承"><a href="#1-5-多继承" class="headerlink" title="1.5 多继承"></a>1.5 多继承</h4><blockquote>
<p> 一个子类可以同时继承多个父类，这样的设计常被人诟病，一来它有可能导致可恶的菱形问题，二来在人的世界观里继承应该是个”is-a”关系。 比如轿车类之所以可以继承交通工具类，是因为基于人的世界观，我们可以说：轿车是一个(“is-a”)交通工具，而在人的世界观里，一个物品不可能是多种不同的东西，因此多重继承在人的世界观里是说不通的，它仅仅只是代码层面的逻辑。不过有没有这种情况，一个类的确是需要继承多个类呢？</p>
<p> 答案是有，我们还是拿交通工具来举例子:</p>
<p> 民航飞机、直升飞机、轿车都是一个（is-a）交通工具，前两者都有一个功能是飞行fly，但是轿车没有，所以如下所示我们把飞行功能放到交通工具这个父类中是不合理的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>:  <span class="comment"># 交通工具</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        飞行功能相应的代码        </span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am flying&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CivilAircraft</span>(<span class="title class_ inherited__">Vehicle</span>):  <span class="comment"># 民航飞机</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Helicopter</span>(<span class="title class_ inherited__">Vehicle</span>):  <span class="comment"># 直升飞机</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">Vehicle</span>):  <span class="comment"># 汽车并不会飞，但按照上述继承关系，汽车也能飞了</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 但是如果民航飞机和直升机都各自写自己的飞行fly方法，又违背了代码尽可能重用的原则（如果以后飞行工具越来越多，那会重复代码将会越来越多）。</p>
<p> 怎么办？？？为了尽可能地重用代码，那就只好在定义出一个飞行器的类，然后让民航飞机和直升飞机同时继承交通工具以及飞行器两个父类，这样就出现了多重继承。这时又违背了继承必须是”is-a”关系</p>
</blockquote>
<blockquote>
<p>Python语言可没有接口功能，但Python提供了Mixins机制，简单来说Mixins机制指的是子类混合(mixin)不同类的功能，而这些类采用统一的命名规范（例如Mixin后缀），以此标识这些类只是用来混合功能的，并不是用来标识子类的从属”is-a”关系的，所以Mixins机制本质仍是多继承，但同样遵守”is-a”关系，如下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>:  <span class="comment"># 交通工具</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyableMixin</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        飞行功能相应的代码        </span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am flying&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CivilAircraft</span>(FlyableMixin, Vehicle):  <span class="comment"># 民航飞机</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Helicopter</span>(FlyableMixin, Vehicle):  <span class="comment"># 直升飞机</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">Vehicle</span>):  <span class="comment"># 汽车</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps: 采用某种规范（如命名规范）来解决具体的问题是python惯用的套路</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，上面的CivilAircraft、Helicopter类实现了多继承，不过它继承的第一个类我们起名为FlyableMixin，而不是Flyable，这个并不影响功能，但是会告诉后来读代码的人，这个类是一个Mixin类，表示混入(mix-in)，这种命名方式就是用来明确地告诉别人（python语言惯用的手法），这个类是作为功能添加到子类中，而不是作为父类，它的作用同Java中的接口。所以从含义上理解，CivilAircraft、Helicopter类都只是一个Vehicle，而不是一个飞行器。</p>
<p>使用Mixin类实现多重继承要非常小心</p>
<ul>
<li>首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀</li>
<li>其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类</li>
<li>然后，它不依赖于子类的实现</li>
<li>最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了）</li>
</ul>
</blockquote>
<h4 id="1-6-子类派生的新方法中重用父类方法"><a href="#1-6-子类派生的新方法中重用父类方法" class="headerlink" title="1.6 子类派生的新方法中重用父类方法"></a>1.6 子类派生的新方法中重用父类方法</h4><blockquote>
<p>子类可以派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找，例如每个老师还有职称这一属性，我们就需要在Teacher类中定义该类自己的<code>__init__</code>覆盖父类的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line"><span class="meta">... </span>    school=<span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,sex,age</span>):</span><br><span class="line"><span class="meta">... </span>        self.name=name</span><br><span class="line"><span class="meta">... </span>        self.sex=sex</span><br><span class="line"><span class="meta">... </span>        self.age=age</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,sex,age,title</span>): <span class="comment"># 派生</span></span><br><span class="line"><span class="meta">... </span>        self.name=name</span><br><span class="line"><span class="meta">... </span>        self.sex=sex</span><br><span class="line"><span class="meta">... </span>        self.age=age</span><br><span class="line"><span class="meta">... </span>        self.title=title</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">teach</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;%s is teaching&#x27;</span> %self.name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj=Teacher(<span class="string">&#x27;lili&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;高级讲师&#x27;</span>) <span class="comment">#只会找自己类中的__init__，并不会自动调用父类的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.name,obj.sex,obj.age,obj.title</span><br><span class="line">(<span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;高级讲师&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很明显子类Teacher中<code>__init__</code>内的前三行又是在写重复代码，若想在子类派生出的方法内重用父类的功能，有两种实现方式</p>
<p>方法一：“指名道姓”地调用某一个类的函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,sex,age,title</span>):</span><br><span class="line"><span class="meta">... </span>        People.__init__(self,name,age,sex) <span class="comment">#调用的是函数,因而需要传入self</span></span><br><span class="line"><span class="meta">... </span>        self.title=title</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">teach</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;%s is teaching&#x27;</span> %self.name)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法二：super()</p>
<p>调用super()会得到一个特殊的对象，该对象专门用来引用父类的属性，且严格按照MRO规定的顺序向后查找</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">People</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,sex,age,title</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().__init__(name,age,sex) <span class="comment">#调用的是绑定方法，自动传入self</span></span><br><span class="line"><span class="meta">... </span>        self.title=title</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">teach</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;%s is teaching&#x27;</span> %self.name)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：在Python2中super的使用需要完整地写成super(自己的类名,self) ,而在python3中可以简写为super()。</p>
<p>这两种方式的区别是：方式一是跟继承没有关系的，而方式二的super()是依赖于继承的，并且即使没有直接继承关系，super()仍然会按照MRO继续往后查找</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#A没有继承B</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">super</span>().test()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;from B&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">C</span>(A,B):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.mro() <span class="comment"># 在代码层面A并不是B的子类，但从MRO列表来看，属性查找时，就是按照顺序C-&gt;A-&gt;B-&gt;object，B就相当于A的“父类”</span></span><br><span class="line">[&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.B&#x27;</span>&gt;,&lt;<span class="keyword">class</span> ‘<span class="built_in">object</span><span class="string">&#x27;&gt;]</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj=C()</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj.test() # 属性查找的发起者是类C的对象obj，所以中途发生的属性查找都是参照C.mro()</span></span><br><span class="line"><span class="string">from B</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>obj.test()首先找到A下的test方法，执行super().test()会基于MRO列表(以C.mro()为准)当前所处的位置继续往后查找()，然后在B中找到了test方法并执行。</p>
<p>关于在子类中重用父类功能的这两种方式，使用任何一种都可以，但是在最新的代码中还是推荐使用super()</p>
</blockquote>
<h4 id="1-7、继承的知识扩展"><a href="#1-7、继承的知识扩展" class="headerlink" title="1.7、继承的知识扩展"></a>1.7、继承的知识扩展</h4><h5 id="1-1-1-子类继承语法"><a href="#1-1-1-子类继承语法" class="headerlink" title="1.1.1 子类继承语法"></a>1.1.1 子类继承语法</h5><blockquote>
<p>语法：class  子类名(父类名):pass</p>
<p>子类可以使用父类中的： 方法  静态变量</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子类可以使用父类中的： 方法  静态变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is drinking&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climb_tree</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is climbing&quot;</span>)</span><br><span class="line"></span><br><span class="line">s = Cat(<span class="string">&quot;xxmo&quot;</span>)</span><br><span class="line">s.eat()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先开辟空间，空间里有一个类指针－＞指向Cat</span></span><br><span class="line"><span class="comment"># 调用init，对象在自己的空间中找init没找到，到Cat类中找init也没找到</span></span><br><span class="line"><span class="comment"># 找父类Animal中的init</span></span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-子类方法中调用父类方法"><a href="#1-1-2-子类方法中调用父类方法" class="headerlink" title="1.1.2 子类方法中调用父类方法"></a>1.1.2 子类方法中调用父类方法</h5><blockquote>
<p>子类的对象，如果去调用方法，永远先调用自己的方法</p>
<p>1.如果自己有该方法，则用自己的，语法： self.子类方法</p>
<p>2.如果自己没有，则使用父类的，语法：self.父类方法</p>
<p>3.如果子类方法和父类方法重名，也就是自己有该方法，父类也有该方法，此时子类方法还想调用父类的方法，则直接在子类方法中调用父类的方法，调用方式： 父类名.方法名(self)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is drinking&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子类的eat方法&quot;</span>)</span><br><span class="line">        Animal.eat(self)  <span class="comment"># 因为子类和父类都有eating方法，仍想调用父类的eating就使用： 父类名.父类方法(self) </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climb_tree</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is climbing&quot;</span>)</span><br><span class="line">        self.drink() <span class="comment"># 因为子类没有drink方法，但是父类有drink方法，所以直接调用父类的drink方法</span></span><br><span class="line"></span><br><span class="line">s = Cat(<span class="string">&quot;xxmo&quot;</span>)</span><br><span class="line">s.eat() </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特殊例子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.func() <span class="comment"># 在每一个self调用func时，不看这句话在哪执行，只看self是谁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in Foo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in Son&quot;</span>)</span><br><span class="line"></span><br><span class="line">Son()</span><br></pre></td></tr></table></figure>

<h5 id="1-1-3-重写父类的-init-构造方法"><a href="#1-1-3-重写父类的-init-构造方法" class="headerlink" title="1.1.3 重写父类的__init__构造方法"></a>1.1.3 重写父类的<code>__init__</code>构造方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drink</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is drinking&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,color</span>):</span><br><span class="line">        Animal.__init__(self,name) <span class="comment"># 调用父类的初始化，完成一些通用属性的初始化</span></span><br><span class="line">        self.age = age  <span class="comment"># 属于子类(派生类)的数据属性</span></span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        msg = <span class="string">f&quot;My cat name is <span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;self.age&#125;</span> years old,It\&#x27;s <span class="subst">&#123;self.color&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line">s = Cat(<span class="string">&quot;kim&quot;</span>,<span class="number">18</span>,<span class="string">&quot;red&quot;</span>)</span><br><span class="line">s.walk()</span><br></pre></td></tr></table></figure>

<h3 id="5、多态"><a href="#5、多态" class="headerlink" title="5、多态"></a>5、多态</h3><blockquote>
<p>多态就是同一事物有多种形态，比如水有冰、水蒸气</p>
<p>所以多态就是在继承背景下的一种描述</p>
<p>多态性本质是可以在不考虑对象具体类型的情况下而直接使用对象</p>
<p>也就是不同的类型有了公共的方法，那就是多态了，也就是接口的概念</p>
<p>但是python的多态不是继承来实现</p>
</blockquote>
<h4 id="1-1-继承方法实现多态"><a href="#1-1-继承方法实现多态" class="headerlink" title="1.1 继承方法实现多态"></a>1.1 继承方法实现多态</h4><blockquote>
<p>下面是继承的实现了多态，Person  Dog类型都有say方法</p>
<p>但是这不是python推荐的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is Animal长度&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is person say&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is dog say&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 = Person()</span><br><span class="line">obj2 = Dog()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这就是多态，不同类型对象可使用相同的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_say</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.say()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_say(obj1)</span><br><span class="line">show_say(obj2)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-鸭子类型"><a href="#1-2-鸭子类型" class="headerlink" title="1.2 鸭子类型"></a>1.2 鸭子类型</h4><blockquote>
<p>python的鸭子类型其实理解下来就是类型和方法长得像，那就是鸭子类型</p>
<p>其实说白了就是有些像go语言的接口类型，接口类型的方法、方法的入参、方法的返回值都必须满足实现，那就是接口类型，也就是鸭子类型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is person say&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is dog say&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 = Person()</span><br><span class="line">obj2 = Dog()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这就是多态，不同类型对象可使用相同的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_say</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.say()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_say(obj1)</span><br><span class="line">show_say(obj2)</span><br></pre></td></tr></table></figure>



<h3 id="6、绑定方法"><a href="#6、绑定方法" class="headerlink" title="6、绑定方法"></a>6、绑定方法</h3><blockquote>
<p>绑定方法特殊之处在于将调用者当做第一个参数自动传入</p>
<ol>
<li>绑定给对象的方法：<ol>
<li>调用者是对象，自动传入的是类</li>
</ol>
</li>
<li>绑定给类的方法：<ol>
<li>调用者是类，自动传入的是类</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql_conf = &#123;</span><br><span class="line">    <span class="string">&quot;ip&quot;</span>:<span class="string">&quot;1.1.1.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>:<span class="number">3306</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mysql</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,ip,port</span>):</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.ip&#125;</span>:<span class="subst">&#123;self.port&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod  </span><span class="comment"># 将下面的函数装饰成绑定类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_conf</span>(<span class="params">xxx</span>):</span><br><span class="line">        <span class="built_in">print</span>(xxx) <span class="comment"># 代表传入的类本身</span></span><br><span class="line">        <span class="keyword">return</span> xxx(mysql_conf[<span class="string">&quot;ip&quot;</span>],mysql_conf[<span class="string">&quot;port&quot;</span>])</span><br><span class="line"></span><br><span class="line">b1 = Mysql.from_conf()</span><br><span class="line"><span class="built_in">print</span>(b1.__dict__)</span><br></pre></td></tr></table></figure>

<h3 id="7、反射"><a href="#7、反射" class="headerlink" title="7、反射"></a>7、反射</h3><h4 id="1-1-反射基础"><a href="#1-1-反射基础" class="headerlink" title="1.1 反射基础"></a>1.1 反射基础</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109336120">https://zhuanlan.zhihu.com/p/109336120</a></p>
</blockquote>
<blockquote>
<p>python是动态语言，而反射(reflection)机制被视为动态语言的关键。</p>
<p>反射机制指的是在程序的运行状态中</p>
<ul>
<li><p>对于任意一个类，都可以知道这个类的所有属性和方法；</p>
</li>
<li><p>对于任意一个对象，都能够调用他的任意方法和属性。</p>
</li>
<li><p>这种动态获取程序信息以及动态调用对象的功能称为反射机制。</p>
</li>
</ul>
</blockquote>
<h4 id="1-2-反射实现"><a href="#1-2-反射实现" class="headerlink" title="1.2 反射实现"></a>1.2 反射实现</h4><blockquote>
<p>在python中实现反射非常简单，在程序运行过程中，如果我们获取一个不知道存有何种属性的对象，若想操作其内部属性，可以先通过内置函数<code>dir(obj)</code>来获取任意一个类或者对象的属性列表，列表中全为字符串格式</p>
</blockquote>
<blockquote>
<p>先通过<code>dir()</code> 查出某一个对象下有哪些属性可以来用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,gender</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">        self.gender=gender</span><br><span class="line"> </span><br><span class="line">obj=People(<span class="string">&#x27;egon&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"><span class="built_in">dir</span>(obj) <span class="comment"># 列表中查看到的属性全为字符串</span></span><br><span class="line">[......,<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;name&#x27;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以通过字符串反射到真正的属性上，得到属性值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dir(obj)[-2] ： 取的是属性列表的倒数第二个属性，即：gender</span></span><br><span class="line"><span class="comment"># print(obj.__dict__) # &#123;&#x27;name&#x27;: &#x27;sam&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以: obj.__dict__[dir(obj)[-2]] 就是 obj.__dict__[&quot;gender&quot;]=&gt; male</span></span><br><span class="line"><span class="built_in">print</span>(obj.__dict__[<span class="built_in">dir</span>(obj)[-<span class="number">2</span>]]) <span class="comment"># male</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-反射内置方法"><a href="#1-3-反射内置方法" class="headerlink" title="1.3 反射内置方法"></a>1.3 反射内置方法</h4><blockquote>
<ul>
<li>通过字符串来操作对象的属性了，这就涉及反射的内置函数<ul>
<li>hasattr</li>
<li>getattr</li>
<li>setattr</li>
<li>delattr</li>
</ul>
</li>
<li>Python中一切皆对象，类和对象都可以被这四个函数操作，用法一样</li>
</ul>
</blockquote>
<h5 id="1-1-1-hasattr"><a href="#1-1-1-hasattr" class="headerlink" title="1.1.1 hasattr"></a>1.1.1 hasattr</h5><blockquote>
</blockquote>
<h5 id="1-1-2-getattr"><a href="#1-1-2-getattr" class="headerlink" title="1.1.2 getattr"></a>1.1.2 getattr</h5><blockquote>
<p>getattr用来判断对象是否有属性，没有的话给一个默认值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;use get method&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;use get method&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">method_not_allow</span>(<span class="params">method_str</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;【<span class="subst">&#123;method_str&#125;</span>】 method not allow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    obj = A()</span><br><span class="line">    method_str = <span class="string">&quot;data&quot;</span></span><br><span class="line">    res = <span class="built_in">getattr</span>(obj, method_str, method_not_allow(method_str))</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="built_in">print</span>(res())</span><br></pre></td></tr></table></figure>

<h5 id="1-1-3-setattr"><a href="#1-1-3-setattr" class="headerlink" title="1.1.3 setattr"></a>1.1.3 setattr</h5><blockquote>
</blockquote>
<h5 id="1-1-4-delattr"><a href="#1-1-4-delattr" class="headerlink" title="1.1.4 delattr"></a>1.1.4 delattr</h5><blockquote>
</blockquote>
<h3 id="7、with上下文"><a href="#7、with上下文" class="headerlink" title="7、with上下文"></a>7、with上下文</h3><blockquote>
<p>with上下文可以在没有进行关闭操作时，自动去进行关闭收尾操作</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenFile</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.timer = time.strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># print(&#x27;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&#x27;)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.timer&#125;</span> 开始读取内容&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.timer&#125;</span> 读取内容完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="comment"># print(&#x27;with中代码块执行完毕时执行我啊&#x27;)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.timer&#125;</span> 自动关闭文件打开的文件句柄&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> OpenFile(<span class="string">&#x27;a.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;执行代码块&lt;&lt;&lt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;done!!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<img src="/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/image-20230217135129406.png" class="" title="image-20230217135129406">

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.lynote.top">刘阳</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.lynote.top/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/">https://www.lynote.top/2022/05/16/python/python%E7%AC%94%E8%AE%B0/python%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.lynote.top" target="_blank">笔记小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="/posts_cover_img/python/python_logo.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/16/golang/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><img class="prev-cover" src="/posts_cover_img/golang/go_code.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go并发编程</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/16/python/django%E7%AC%94%E8%AE%B0/django%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/posts_cover_img/python/django.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Django笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/28/python/python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" title="Python异步编程"><img class="cover" src="/posts_cover_img/python/python_logo.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-28</div><div class="title">Python异步编程</div></div></a></div><div><a href="/2022/05/16/python/django%E7%AC%94%E8%AE%B0/django%E7%AC%94%E8%AE%B0/" title="Django笔记"><img class="cover" src="/posts_cover_img/python/django.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-16</div><div class="title">Django笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">刘阳</div><div class="author-info__description">学习与记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lyzin"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">一、基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">1、变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">1.1 变量的三大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-is%E5%92%8C-x3D-x3D"><span class="toc-text">1.2 is和&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%B8%B8%E9%87%8F"><span class="toc-text">1.3 常量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81str%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2、str字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81bool%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-text">3、bool布尔值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81list%E5%88%97%E8%A1%A8"><span class="toc-text">4、list列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81tuple%E5%85%83%E7%BB%84"><span class="toc-text">5、tuple元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%AD%97%E5%85%B8"><span class="toc-text">6、字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">7、垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-text">1.1 引用计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-text">1.2 标记清除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-text">1.3  分代回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="toc-text">8、编解码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-str%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.1 str类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-bytes%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.2 bytes类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.3 编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">9、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.1 算数运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.2 逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BA%AB%E4%BB%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.3 成员运算符和身份运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">二、流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81if-else%E5%88%A4%E6%96%AD"><span class="toc-text">1、if-else判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81if-elif-else%E5%88%A4%E6%96%AD"><span class="toc-text">2、if-elif-else判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81for%E5%BE%AA%E7%8E%AF"><span class="toc-text">3、for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81while%E5%BE%AA%E7%8E%AF"><span class="toc-text">4、while循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">三、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">1、为什么要用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-text">2、函数的结构与调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81return%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">3、return函数的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%BD%A2%E5%8F%82%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E3%80%81%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">4、形参、关键字参数、默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%B8%87%E8%83%BD%E5%8F%82%E6%95%B0-args%E5%92%8C-kwargs"><span class="toc-text">5、万能参数:*args和**kwargs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">6、函数的名称空间、作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">7、高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81globals-%E5%92%8C-locals"><span class="toc-text">8、globals() 和 locals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81global%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8"><span class="toc-text">9、global关键字作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81nonlocal%E5%85%B3%E9%94%AE%E5%AD%97-%E4%BD%BF%E7%94%A8%E8%BE%83%E5%B0%91"><span class="toc-text">10、nonlocal关键字(使用较少)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-text">11、默认参数、作用域的陷阱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%87%BD%E6%95%B0%E5%90%8D%E5%BA%94%E7%94%A8"><span class="toc-text">12、函数名应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0"><span class="toc-text">13、闭包函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-text">1.1 什么是闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E6%96%B0%E5%A4%8D%E4%B9%A0%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0"><span class="toc-text">1.1.1 新复习闭包函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E5%8E%86%E5%8F%B2%E5%A4%8D%E4%B9%A0"><span class="toc-text">1.1.2 历史复习</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-text">1.2 判断函数是不是闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">14、格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA"><span class="toc-text">15、函数的类型提示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Python%E5%86%85%E7%BD%AE%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="toc-text">四、Python内置语法使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1、三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">2、迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">3、生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-text">4、推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">5、装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5import"><span class="toc-text">6、模块导入import</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85"><span class="toc-text">7、模块和包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%A8%A1%E5%9D%97"><span class="toc-text">1.1 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5"><span class="toc-text">7.2 模块导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83"><span class="toc-text">7.3 导入模块规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E8%B5%B7%E5%88%AB%E5%90%8D"><span class="toc-text">7.4 模块导入起别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">五、常用模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81OS%E6%A8%A1%E5%9D%97"><span class="toc-text">1、OS模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81SYS%E6%A8%A1%E5%9D%97"><span class="toc-text">2、SYS模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81logging%E6%A8%A1%E5%9D%97"><span class="toc-text">3、logging模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-text">4、内置函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81time%E6%A8%A1%E5%9D%97"><span class="toc-text">5、time模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-time-time"><span class="toc-text">1.1 time.time()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-time-localtime"><span class="toc-text">1.2 time.localtime()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-time-strftime"><span class="toc-text">1.3 time.strftime()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-time-strptime"><span class="toc-text">1.4 time.strptime()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-time-mktime"><span class="toc-text">1.5 time.mktime()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E9%97%B4"><span class="toc-text">1.5 时间戳转换为字符串时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E9%97%B4%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">1.6 字符串时间转化为时间戳</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81datetime%E6%A8%A1%E5%9D%97"><span class="toc-text">6、datetime模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4"><span class="toc-text">1.1 当前时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%97%B6%E9%97%B4%E5%8A%A0%E5%87%8F"><span class="toc-text">1.2 时间加减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BAdatetime%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E9%97%B4"><span class="toc-text">1.3 时间戳转化为datetime类型的字符串时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-datetime%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E9%97%B4%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">1.4 datetime类型的字符串时间转化为时间戳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-datetime%E5%92%8Ctime%E6%A8%A1%E5%9D%97%E5%A4%8D%E4%B9%A0"><span class="toc-text">1.5 datetime和time模块复习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">六、正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1、正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%85%83%E5%AD%97%E7%AC%A6"><span class="toc-text">2、元字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x%E3%80%81%E6%AD%A3%E5%88%99%E5%B0%8F%E4%BE%8B%E5%AD%90"><span class="toc-text">x、正则小例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x-1-%E5%88%87%E5%89%B2cookies%E4%B8%BA%E5%AD%97%E5%85%B8"><span class="toc-text">x.1 切割cookies为字典</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">七、进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B"><span class="toc-text">1、进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-text">2、并发与并行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B9%B6%E5%8F%91"><span class="toc-text">1.1 并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%B9%B6%E8%A1%8C"><span class="toc-text">1.2 并行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">3、同步、异步、阻塞、非阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%90%8C%E6%AD%A5"><span class="toc-text">1.1 同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%BC%82%E6%AD%A5"><span class="toc-text">1.2 异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E9%98%BB%E5%A1%9E"><span class="toc-text">1.3 阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">1.4 非阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-text">4、线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81threading%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">5、threading多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">6、线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">八、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-text">1、类定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">1.1 类的实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="toc-text">1.2 类的属性查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95%E5%B0%B1%E6%98%AF%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-text">1.3 对象使用类方法就是绑定方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E4%B8%89%E5%A4%A7%E5%B1%9E%E6%80%A7"><span class="toc-text">2、类的三大属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%B0%81%E8%A3%85"><span class="toc-text">3、封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E3%80%81%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">1.1 私有变量、私有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-property"><span class="toc-text">1.2 property</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-text">4、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E9%AA%A8%E6%9E%B6"><span class="toc-text">1.1 继承的骨架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="toc-text">1.2 继承的属性查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%8D%95%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="toc-text">1.3 单继承的属性查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86"><span class="toc-text">1.4 继承原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">1.5 多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E5%AD%90%E7%B1%BB%E6%B4%BE%E7%94%9F%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95%E4%B8%AD%E9%87%8D%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">1.6 子类派生的新方法中重用父类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95"><span class="toc-text">1.7、继承的知识扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">1.1.1 子类继承语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">1.1.2 子类方法中调用父类方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E7%9A%84-init-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">1.1.3 重写父类的__init__构造方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-text">5、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="toc-text">1.1 继承方法实现多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.2 鸭子类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-text">6、绑定方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-text">7、反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80"><span class="toc-text">1.1 反射基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2 反射实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%8F%8D%E5%B0%84%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-text">1.3 反射内置方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-hasattr"><span class="toc-text">1.1.1 hasattr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-getattr"><span class="toc-text">1.1.2 getattr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-setattr"><span class="toc-text">1.1.3 setattr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4-delattr"><span class="toc-text">1.1.4 delattr</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81with%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">7、with上下文</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/28/java/Mybatis%E4%BD%BF%E7%94%A8/Mybatis%E4%BD%BF%E7%94%A8/" title="Mybatis使用"><img src="/img/index.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis使用"/></a><div class="content"><a class="title" href="/2024/09/28/java/Mybatis%E4%BD%BF%E7%94%A8/Mybatis%E4%BD%BF%E7%94%A8/" title="Mybatis使用">Mybatis使用</a><time datetime="2024-09-27T18:33:26.000Z" title="发表于 2024-09-28 02:33:26">2024-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/28/java/Maven%E4%BD%BF%E7%94%A8/Maven%E4%BD%BF%E7%94%A8/" title="Maven使用"><img src="/source/posts_cover_img/java/maven-logo-black-on-white.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Maven使用"/></a><div class="content"><a class="title" href="/2024/09/28/java/Maven%E4%BD%BF%E7%94%A8/Maven%E4%BD%BF%E7%94%A8/" title="Maven使用">Maven使用</a><time datetime="2024-09-27T18:23:10.000Z" title="发表于 2024-09-28 02:23:10">2024-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/java/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="Java基础语法"><img src="/posts_cover_img/java/java_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础语法"/></a><div class="content"><a class="title" href="/2024/09/22/java/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="Java基础语法">Java基础语法</a><time datetime="2024-09-22T07:08:33.000Z" title="发表于 2024-09-22 15:08:33">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/17/golang/kafka%E4%BD%BF%E7%94%A8/kafka%E4%BD%BF%E7%94%A8/" title="kafka使用"><img src="/posts_cover_img/golang/kafka_logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kafka使用"/></a><div class="content"><a class="title" href="/2024/09/17/golang/kafka%E4%BD%BF%E7%94%A8/kafka%E4%BD%BF%E7%94%A8/" title="kafka使用">kafka使用</a><time datetime="2024-09-17T01:48:14.000Z" title="发表于 2024-09-17 09:48:14">2024-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/11/golang/elasticsearch/elasticsearch%E4%BD%BF%E7%94%A8/" title="elasticsearch使用"><img src="/posts_cover_img/golang/elastic.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="elasticsearch使用"/></a><div class="content"><a class="title" href="/2024/09/11/golang/elasticsearch/elasticsearch%E4%BD%BF%E7%94%A8/" title="elasticsearch使用">elasticsearch使用</a><time datetime="2024-09-11T05:49:03.000Z" title="发表于 2024-09-11 13:49:03">2024-09-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/posts_cover_img/python/python_logo.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 刘阳</div><div class="footer_custom_text">努力终会有回报</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="/pluginsSrc/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>